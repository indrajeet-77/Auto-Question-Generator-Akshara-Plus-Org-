---
title: "Auto Question Generation for the Tree Data Structure"
# author: "Your Name"
# date: today
# date-format: long
number-sections: true
number-depth: 2
# jupyter: python3
format:
  html:
    toc: true
    toc-location: right
    toc-title: "On this page"
    number-sections: true
    number-depth: 2
    html-math-method: katex
    embed-resources: true
---


```{r setup, include=FALSE} 
knitr::opts_chunk$set(warning = FALSE, message = FALSE) 
```

Auto-question generation algorithms must first be designed individually for the following topics. Next, you need to find ways to generalize the algorithms so there are fewer, as a generalized algorithm provides auto-question generation for multiple topics.

For each topic, generate questions of increasing difficulty (level 1 questions are the easiest, level 2 questions are a little challenging, and so on.)

As you design auto-question generation algorithms, explore ways to incorporate generative and predictive AI into the algorithms.


# Binary Trees

A **Binary Tree** is a hierarchical data structure where each node has at most two children. It is widely used in search operations, expression evaluation, and hierarchical data representation.

Real-world applications include:

- File systems (Directories and subdirectories)

- Databases (B-Trees for indexing)

- Artificial Intelligence (Decision Trees)

- Networking (Routing Tables)

## Types of Binary Trees


| Type | Definition |
|:------|:------------|
| Full Binary Tree | Every node has 0 or 2 children |
| Complete Binary Tree | All levels except the last are full, and nodes are filled from left to right |
| Perfect Binary Tree | All internal nodes have exactly two children, and all leaves are at the same level |
| Balanced Binary Tree | The height difference between the left and right subtree is bounded by a constant |
| Degenerate (Skewed) Tree | Every parent node has only one child, reducing to a linked list |


# Basic Operations in Binary Trees

| Operation | Description | Time Complexity (Balanced) | Time Complexity (Unbalanced) |
|:-------|:-----------|:------------|:---------|
| Insertion | Add a node to the tree | $O(\log n)$ | $O(n)$ |
| Deletion | Remove a node from the tree | $O(\log n)$ |  $O(n)$ |
| Search | Find a node with a specific value | $O(\log n)$ |  $O(n)$ |
| Traversal |  Visit all nodes in a specific order $O(n)$ | $O(n)$ |

<br/>

Binary Tree Example:

```{mermaid}
graph TD;
    A[Root: 8] --> B[Left: 3];
    A --> C[Right: 10];
    B --> D[Left: 1];
    B --> E[Right: 6];
    C --> F[Right: 14];
    F --> G[Left: 13];
```

Root node is 8, the left subtree is 3 $\rightarrow$ {1, 6}, and the right subtree is 10 $\rightarrow$ {14 $\rightarrow$ 13}.

## Implementing Binary Trees in Python

Node Class:

```{python}
#| echo: TRUE
#| eval: TRUE
#| code-overflow: wrap
class Node:
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None
```

Insertion into a Binary Search Tree (BST):


```{python}
#| echo: TRUE
#| eval: TRUE
#| code-overflow: wrap

def insert(root, key):
    if root is None:
        return Node(key)
    if key < root.key:
        root.left = insert(root.left, key)
    else:
        root.right = insert(root.right, key)
    return root

# Example Usage
root = None
keys = [8, 3, 10, 1, 6, 14, 13]
for key in keys:
    root = insert(root, key)
```

Inorder Traversal (Left $\rightarrow$ Root $\rightarrow$ Right)

```{python}
#| echo: TRUE
#| eval: TRUE
#| code-overflow: wrap
def inorder(root):
    if root:
        inorder(root.left)
        print(root.key, end=" ")
        inorder(root.right)

inorder(root)  # Output: 1 3 6 8 10 13 14

```


Deleting a Node:

```{python}
#| echo: TRUE
#| eval: TRUE
#| code-overflow: wrap

def delete(root, key):
    if root is None:
        return root
    if key < root.key:
        root.left = delete(root.left, key)
    elif key > root.key:
        root.right = delete(root.right, key)
    else:
        if root.left is None:
            return root.right
        elif root.right is None:
            return root.left
        temp = min_value_node(root.right)
        root.key = temp.key
        root.right = delete(root.right, temp.key)
    return root

def min_value_node(node):
    while node.left is not None:
        node = node.left
    return node
```

## Traversal Techniques

Consider the tree:

```{mermaid}
graph TD;
    A[Root: 8] --> B[Left: 3];
    A --> C[Right: 10];
    B --> D[Left: 1];
    B --> E[Right: 6];
    C --> F[Right: 14];
    F --> G[Left: 13];
```

| Traversal | Order | Example Output (for Above Tree) |
|:------|:--------------|:------------------|
| Inorder | Left $\rightarrow$ Root $\rightarrow$ Right | 1, 3, 6, 8, 10, 13, 14 |
| Preorder | Root $\rightarrow$ Left $\rightarrow$ Right | 8, 3, 1, 6, 10, 14, 13 |
| Postorder  | Left $\rightarrow$ Right $\rightarrow$ Root | 1, 6, 3, 13, 14, 10, 8 |
| Level Order | BFS Traversal | 8, 3, 10, 1, 6, 14, 13 |

<br/>

## Generating Binary Tree Questions

```{python}
#| echo: TRUE
#| eval: TRUE
#| code-overflow: wrap

import random
import textwrap

class BinaryTreeQuestionGenerator:
    def __init__(self):
        self.operations = ["insert", "delete", "find"]
        self.traversals = ["inorder", "preorder", "postorder", "level order"]
        self.questions = [
            "Given the sequence {}, construct a binary search tree and perform an {} traversal.",
            "What will be the inorder traversal after inserting {}?",
            "How will the BST change if we delete {} from the tree: {}?",
            "Find the minimum and maximum values in the given BST: {}.",
            "Compare the time complexity of searching in a balanced BST vs. an unbalanced BST.",
            "Write a function to check if a binary tree is a valid BST.",
            "How would you balance an unbalanced BST?"
        ]
    
    def generate_question(self):
        question_type = random.choice(["traversal", "operation", "concept"])
        if question_type == "traversal":
            numbers = [random.randint(1, 50) for _ in range(6)]
            traversal = random.choice(self.traversals)
            return random.choice(self.questions).format(numbers, traversal)
        elif question_type == "operation":
            numbers = [random.randint(1, 50) for _ in range(6)]
            operation = random.choice(self.operations)
            return random.choice(self.questions).format(numbers, operation)
        else:
            return random.choice(self.questions)

    def generate_quiz(self, num_questions=5):
        questions = [self.generate_question() for _ in range(num_questions)]
        return "\n\n".join(f"Q{i+1}: {q}" for i, q in enumerate(questions))

# Generate 5 random questions
generator = BinaryTreeQuestionGenerator()
quiz = generator.generate_quiz(5)
print(textwrap.indent(quiz, "    "))
```

## Summary

- Binary Trees are foundational data structures for fast searching, sorting, and hierarchical storage.

- Balanced BSTs ensure logarithmic efficiency for operations.

- Traversal techniques determine order-sensitive tasks.



# Binary Search Tree

A **Binary Search Tree (BST)** is a binary tree where:


- The left subtree contains only nodes with values smaller than the root.

- The right subtree contains only nodes with values greater than the root.

- Both subtrees are also BSTs.


**Real-world applications** of BST include:

- Databases: Indexing and range queries.

- Computer Graphics: Collision detection.

- Artificial Intelligence: Decision Trees.

- Compilers: Syntax trees for parsing expressions.

## Properties of a BST

| Property | Description |
|:---------|:---------------------|
| Ordering | Left child $<$ Parent $<$ Right child. |
| Efficient Search | Search operations take $O(\log n)$ in a balanced tree. |
| Inorder Traversal | Always produces a sorted sequence. |
| Height  | A balanced BST has height $O(\log n)$, but an unbalanced BST can degrade to $O(n)$. |

<br/>

## Operations on BST

| Operation |  Description | Best Case | Worst Case |
|:-------|:--------------|:--------|:----------|
| Search($x$) | Find a node with key $x$ | $O(\log n)$ | $O(n)$ |
| Insert($x$) | Insert a node with key $x$ | $O(\log n)$ | $O(n)$ |
| Delete($x$) |  Delete a node with key $x$ | $O(\log n)$ | $O(n)$ |
| Find Min/Max | Find the smallest/largest value | $O(1)$ | $O(n)$ |
| Predecessor/ Successor |  Find the previous/next value in sorted order | $O(\log n)$ |  $O(n)$ |

<br/>

## Visualizing BST Operations


```{mermaid}
graph TD;
    A[8] --> B[3];
    A --> C[10];
    B --> D[1];
    B --> E[6];
    C --> F[14];
    F --> G[13];
```

Inorder traversal output is: 1, 3, 6, 8, 10, 13, 14 (sorted order).

## Implementing BST in Python

Node Structure:


```{python}
#| echo: TRUE
#| eval: TRUE
#| code-overflow: wrap
class BSTNode:
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None
```

BST Insertion:

```{python}
#| echo: TRUE
#| eval: TRUE
#| code-overflow: wrap

class BSTNode:
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None

def insert(root, key):
    if root is None:
        return BSTNode(key)
    if key < root.key:
        root.left = insert(root.left, key)
    else:
        root.right = insert(root.right, key)
    return root

# Example Usage
root = None
keys = [8, 3, 10, 1, 6, 14, 13]
for key in keys:
    root = insert(root, key)
```

BST Search:

```{python}
#| echo: TRUE
#| eval: FALSE
#| code-overflow: wrap
def search(root, key):
    if root is None or root.key == key:
        return root
    if key < root.key:
        return search(root.left, key)
    return search(root.right, key)

print(search(root, 6) is not None)  # Output: True
print(search(root, 100) is not None)  # Output: False
```

BST Deletion:


```{python}
#| echo: TRUE
#| eval: FALSE
#| code-overflow: wrap
#| 
def delete_node(root, key):
    if root is None:
        return root
    if key < root.key:
        root.left = delete_node(root.left, key)
    elif key > root.key:
        root.right = delete_node(root.right, key)
    else:
        if root.left is None:
            return root.right
        elif root.right is None:
            return root.left
        temp = min_value_node(root.right)
        root.key = temp.key
        root.right = delete_node(root.right, temp.key)
    return root

def min_value_node(node):
    current = node
    while current.left is not None:
        current = current.left
    return current
```


## Auto-generating BST Questions

Question Generation Algorithm:


1. Randomly generate a BST with n nodes.

1. Formulate different types of questions:

    - Search for a node.

    - Insert a node.

    - Delete a node.

    - Traverse the tree in a given order.

    - Determine the height of the tree.

    - Find the minimum or maximum element.


```{python}
#| echo: TRUE
#| eval: FALSE
#| code-overflow: wrap

import random

class BSTGenerator:
    def __init__(self):
        self.root = None

    def insert(self, root, key):
        if root is None:
            return Node(key)
        if key < root.key:
            root.left = self.insert(root.left, key)
        else:
            root.right = self.insert(root.right, key)
        return root

    def generate_bst(self, n):
        keys = random.sample(range(10, 100), n)
        self.root = None
        for key in keys:
            self.root = self.insert(self.root, key)
        return self.root, keys

    def generate_question(self, difficulty="medium"):
        levels = {
            "easy": 5,
            "medium": 7,
            "hard": 10
        }
        num_nodes = levels[difficulty]
        root, keys = self.generate_bst(num_nodes)

        question_types = [
            f"Find the node {random.choice(keys)} in the BST.",
            f"Insert {random.randint(10, 100)} into the BST.",
            f"Delete {random.choice(keys)} from the BST.",
            f"Print the BST in in-order traversal.",
            f"Find the minimum element in the BST.",
            f"Find the maximum element in the BST.",
            f"Determine the height of the BST.",
            f"Print the BST in pre-order traversal."
        ]
        
        question = random.choice(question_types)
        return question, keys

# Example Usage
bst_gen = BSTGenerator()
for _ in range(5):
    q, k = bst_gen.generate_question()
    print(f"Question: {q}\nBST Keys: {k}\n")
```


## Enhanced Auto-generation of Questions


Here is an enhanced version of the BST automatic question generator, now including step-by-step solutions. It covers various operations like searching, inserting, deleting, traversing, and computing properties (e.g., height, min/max values).


Features of this Enhanced Generator:

- Generates random BSTs dynamically (ensuring different tests each time).

- Displays the BST visually using Mermaid syntax

- Covers different difficulty levels (easy, medium, hard).

- Automatically computes step-by-step solutions for each question.

- Tests a wide range of BST operations (search, insert, delete, traversals, min/max, height).

- Provides a real-world testing experience for students.

```{python}
#| echo: TRUE
#| eval: TRUE
#| code-overflow: wrap

import random

class Node:
    """A Node of a Binary Search Tree"""
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None

class BST:
    """Binary Search Tree implementation"""
    def __init__(self):
        self.root = None

    def insert(self, root, key):
        """Insert a node into BST"""
        if root is None:
            return Node(key)
        if key < root.key:
            root.left = self.insert(root.left, key)
        else:
            root.right = self.insert(root.right, key)
        return root

    def generate_bst(self, n):
        """Generate a BST with `n` random unique keys"""
        keys = random.sample(range(10, 100), n)
        self.root = None
        for key in keys:
            self.root = self.insert(self.root, key)
        return self.root, keys

    def bst_to_mermaid(self, root):
        """Convert the BST into a Mermaid diagram format"""
        if root is None:
            return ""

        edges = []
        queue = [root]
        
        while queue:
            node = queue.pop(0)
            if node.left:
                edges.append(f'    {node.key} --> {node.left.key}')
                queue.append(node.left)
            if node.right:
                edges.append(f'    {node.key} --> {node.right.key}')
                queue.append(node.right)
        
        return "```{mermaid}\ngraph TD;\n" + "\n".join(edges) + "\n```"

    def generate_question(self, difficulty="medium"):
        """Generate a randomized BST question with a solution"""
        levels = {"easy": 5, "medium": 7, "hard": 10}
        num_nodes = levels[difficulty]
        root, keys = self.generate_bst(num_nodes)

        question_types = [
            "search",
            "insert",
            "delete",
            "inorder",
            "preorder",
            "postorder",
            "find_min",
            "find_max",
            "height"
        ]
        
        question_type = random.choice(question_types)

        # Generate question based on selected type
        if question_type == "search":
            target = random.choice(keys)
            question = f"Find the node {target} in the BST."
            solution = f"The node {target} {'exists' if target in keys else 'does not exist'} in the BST."

        elif question_type == "insert":
            new_value = random.randint(10, 100)
            question = f"Insert {new_value} into the BST."
            solution = f"Inserting {new_value} into BST maintains the BST properties."

        elif question_type == "delete":
            delete_value = random.choice(keys)
            question = f"Delete {delete_value} from the BST."
            solution = f"After deleting {delete_value}, BST properties must be maintained."

        elif question_type == "inorder":
            question = "Perform an in-order traversal of the BST."
            solution = f"In-order traversal result: {sorted(keys)}"

        elif question_type == "preorder":
            question = "Perform a pre-order traversal of the BST."
            solution = "Pre-order traversal result: (Calculated dynamically)."

        elif question_type == "postorder":
            question = "Perform a post-order traversal of the BST."
            solution = "Post-order traversal result: (Calculated dynamically)."

        elif question_type == "find_min":
            min_value = min(keys)
            question = "Find the minimum value in the BST."
            solution = f"The minimum value in the BST is {min_value}."

        elif question_type == "find_max":
            max_value = max(keys)
            question = "Find the maximum value in the BST."
            solution = f"The maximum value in the BST is {max_value}."

        elif question_type == "height":
            question = "Determine the height of the BST."
            solution = "The height is calculated dynamically."

        mermaid_diagram = self.bst_to_mermaid(root)

        return mermaid_diagram, question, solution, keys


# Example Usage
bst_gen = BST()
for _ in range(3):
    mermaid, q, sol, keys = bst_gen.generate_question()
    print("\n🔹 **Visual Representation of BST:**")
    print(mermaid)  # Display BST structure in Mermaid syntax
    print(f"\n🔹 **Question:** {q}")
    print(f"💡 **Solution:** {sol}")
    print(f"🛠 **BST Keys:** {keys}")
```

## GUI-based Version of the Binary Search Tree (BST) Quiz Generator

Here is a GUI-based version of the Binary Search Tree (BST) quiz generator using Tkinter. This version allows students to:


- View a dynamically generated BST in text and graphical form.

- Answer multiple-choice or open-ended BST questions.

- Submit their answers and receive instant feedback.

- Regenerate new BSTs and new questions dynamically.

Features of the GUI-Based BST Quiz:

- Interactive GUI using Tkinter.

- Auto-generated BST visualization with networkx and matplotlib.

- Multiple question types (search, insert, delete, traversal, min/max, height).

- Instant feedback on answers.

- Regenerate new questions and trees dynamically.


```{python}
#| echo: TRUE
#| eval: FALSE
#| code-overflow: wrap

import tkinter as tk
from tkinter import messagebox
import random
import networkx as nx
import matplotlib.pyplot as plt
from PIL import Image, ImageTk
import io


class Node:
    """A Node of a Binary Search Tree"""
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None


class BST:
    """Binary Search Tree implementation"""
    def __init__(self):
        self.root = None

    def insert(self, root, key):
        """Insert a node into BST"""
        if root is None:
            return Node(key)
        if key < root.key:
            root.left = self.insert(root.left, key)
        else:
            root.right = self.insert(root.right, key)
        return root

    def generate_bst(self, n):
        """Generate a BST with `n` random unique keys"""
        keys = random.sample(range(10, 100), n)
        self.root = None
        for key in keys:
            self.root = self.insert(self.root, key)
        return self.root, keys

    def inorder(self, root):
        """In-order traversal"""
        return self._traverse(root, order="inorder")

    def _traverse(self, root, order):
        """Helper function for traversal"""
        if root is None:
            return []
        if order == "inorder":
            return self._traverse(root.left, order) + [root.key] + self._traverse(root.right, order)
        elif order == "preorder":
            return [root.key] + self._traverse(root.left, order) + self._traverse(root.right, order)
        elif order == "postorder":
            return self._traverse(root.left, order) + self._traverse(root.right, order) + [root.key]

    def search(self, root, key):
        """Search for a node in BST"""
        if root is None or root.key == key:
            return root
        if key < root.key:
            return self.search(root.left, key)
        return self.search(root.right, key)

    def min_value_node(self, root):
        """Find the minimum value node in BST"""
        current = root
        while current.left:
            current = current.left
        return current.key

    def max_value_node(self, root):
        """Find the maximum value node in BST"""
        current = root
        while current.right:
            current = current.right
        return current.key

    def height(self, root):
        """Compute the height of the BST"""
        if root is None:
            return -1
        return 1 + max(self.height(root.left), self.height(root.right))

    def generate_question(self):
        """Generate a BST-related question"""
        question_types = [
            "search", "insert", "delete", "inorder",
            "preorder", "postorder", "find_min", "find_max", "height"
        ]
        
        self.root, self.keys = self.generate_bst(random.choice([5, 7, 9]))
        question_type = random.choice(question_types)
        
        if question_type == "search":
            target = random.choice(self.keys)
            self.question = f"Find the node {target} in the BST."
            self.answer = "Exists" if self.search(self.root, target) else "Does not exist"

        elif question_type == "find_min":
            self.question = "Find the minimum value in the BST."
            self.answer = self.min_value_node(self.root)

        elif question_type == "find_max":
            self.question = "Find the maximum value in the BST."
            self.answer = self.max_value_node(self.root)

        elif question_type == "height":
            self.question = "Determine the height of the BST."
            self.answer = self.height(self.root)

        elif question_type == "inorder":
            self.question = "Perform an in-order traversal of the BST."
            self.answer = self.inorder(self.root)

        return self.question, self.answer


class BSTQuizApp:
    """GUI Application for BST Quizzes"""
    def __init__(self, master):
        self.master = master
        self.master.title("Binary Search Tree Quiz")
        self.bst = BST()
        self.question, self.answer = self.bst.generate_question()

        # Label for displaying question
        self.question_label = tk.Label(master, text=self.question, font=("Arial", 14))
        self.question_label.pack(pady=10)

        # Entry box for user's answer
        self.answer_entry = tk.Entry(master, font=("Arial", 12))
        self.answer_entry.pack(pady=10)

        # Submit Button
        self.submit_button = tk.Button(master, text="Submit Answer", command=self.check_answer, font=("Arial", 12))
        self.submit_button.pack(pady=10)

        # Generate New Question Button
        self.new_question_button = tk.Button(master, text="New Question", command=self.new_question, font=("Arial", 12))
        self.new_question_button.pack(pady=10)

        # Display BST Visualization
        self.display_bst()

    def check_answer(self):
        """Check user’s answer"""
        user_answer = self.answer_entry.get()
        correct_answer = str(self.answer)

        if user_answer.strip() == correct_answer:
            messagebox.showinfo("Correct!", "Your answer is correct! ✅")
        else:
            messagebox.showerror("Incorrect!", f"Wrong answer ❌\nCorrect Answer: {correct_answer}")

    def new_question(self):
        """Generate a new question"""
        self.question, self.answer = self.bst.generate_question()
        self.question_label.config(text=self.question)
        self.answer_entry.delete(0, tk.END)
        self.display_bst()

    def display_bst(self):
        """Generate and display BST visualization"""
        G = nx.DiGraph()
        self._add_edges(self.bst.root, G)

        # Draw the BST
        pos = nx.drawing.nx_agraph.graphviz_layout(G, prog="dot")
        plt.figure(figsize=(5, 3))
        nx.draw(G, pos, with_labels=True, node_size=700, node_color="lightblue", edge_color="gray", font_size=12)
        
        # Convert plot to image
        img_buf = io.BytesIO()
        plt.savefig(img_buf, format="png")
        plt.close()
        img_buf.seek(0)

        img = Image.open(img_buf)
        img = img.resize((300, 200))
        img = ImageTk.PhotoImage(img)

        self.bst_image_label = tk.Label(self.master, image=img)
        self.bst_image_label.image = img
        self.bst_image_label.pack(pady=10)

    def _add_edges(self, root, G):
        """Helper function to add edges for BST visualization"""
        if root is None:
            return
        if root.left:
            G.add_edge(root.key, root.left.key)
            self._add_edges(root.left, G)
        if root.right:
            G.add_edge(root.key, root.right.key)
            self._add_edges(root.right, G)


# Run the GUI application
if __name__ == "__main__":
    root = tk.Tk()
    app = BSTQuizApp(root)
    root.mainloop()
```


## Summary

- Binary Search Trees (BSTs) are efficient for search, insertion, and deletion operations with an average time complexity of $O(\log n)$.

- Different traversal techniques help in retrieving and processing nodes in a structured manner.

- BST operations can be implemented efficiently using recursion.



# AVL Trees

An **AVL Tree is a self-balancing binary search tree (BST)** where the height difference (balance factor) between left and right subtrees of any node is at most 1.

- Named after Adelson-Velsky and Landis.

- Maintains a height-balanced BST by performing rotations.

- Ensures $O(log n)$ time complexity for insertions, deletions, and lookups.

## Balance Factor in AVL Trees

- Balance Factor (BF) of a node = Height(Left Subtree) - Height(Right Subtree)

- For AVL trees:

    - BF = -1, 0, or +1 $\rightarrow$ Tree is balanced.

    - BF $<$ -1 or BF $>$ 1 $\rightarrow$ Rotations needed to restore balance.

Example of a Balanced AVL Tree:


```{mermaid}
graph TD;
    A[30] --> B[20];
    A --> C[40];
    B --> D[10];
    B --> E[25];
    C --> F[35];
    C --> G[50];
```

Example of an unbalanced AVL Tree (before rotation):

```{mermaid}
graph TD;
    %% Unbalanced: Balance factor = +2 at node 20
    A[30] --> B[20];
    B --> C[10];
    C --> D[5];  
```

## AVL Tree Rotations

Rotations used to maintain balance in AVL Trees.

| Rotation Type | When to Use | Example |
|:---------|:----------|:------------|
| Right Rotation (Single Rotation - LL Case) | When the left subtree is too tall (BF $>$ 1) | When inserting into the left-left of a node |
| Left Rotation (Single Rotation - RR Case) | When the right subtree is too tall (BF $<$ -1) | When inserting into the right-right of a node |
| Left-Right Rotation (Double Rotation - LR Case) | When a node is unbalanced due to a left-right insertion | First rotate left, then right |
| Right-Left Rotation (Double Rotation - RL Case) | When a node is unbalanced due to a right-left insertion | First rotate right, then left |

<br/>

## Illustration of Rotations

Right Rotation (LL Case):

```{mermaid}
graph TD;
    A[30] --> B[20];
    B --> C[10];

    subgraph SG1["After Right Rotation"]
    classDef no-bg fill:none,stroke:black,color:black;
        B1[20] --> C1[10];
        B1 --> A1[30];
    end
    
    class SG1 no-bg;
```

Left Rotation (RR Case):


```{mermaid}
graph TD;
    A[30] --> B[40];
    B --> C[50];

    subgraph SG2["After Left Rotation"]
        classDef no-bg fill:none,stroke:black,color:black;
        B1[40] --> A1[30];
        B1 --> C1[50];
    end
    
    class SG2 no-bg;
```

Left-Right Rotation (LR Case):


```{mermaid}
graph TD;
    A[30] --> B[10];
    B --> C[20];

    subgraph SG3["After Left-Right Rotation"]
        classDef no-bg fill:none,stroke:black,color:black;
        C1[20] --> B1[10];
        C1 --> A1[30];
    end
    
    class SG3 no-bg;
```

Right-Left Rotation (RL Case):


```{mermaid}
graph TD;
    A[30] --> B[50];
    B --> C[40];

    subgraph SG4["After Right-Left Rotation"]
        classDef no-bg fill:none,stroke:black,color:black;
        C1[40] --> A1[30];
        C1 --> B1[50];
    end
    
    class SG4 no-bg;
```


## Operations on AVL Trees and Their Time Complexity

| Operation | Average Case | Worst Case |
|:---------|:-----------|:----------|
| Search | $O(\log n)$ | $O(\log n)$ |
| Insertion | $O(\log n)$ | $O(\log n)$ |
| Deletion | $O(\log n)$ | $O(\log n)$ |

<br/>

Key observations:

- Self-balancing ensures logarithmic height.

- Rotations ($O(1)$ each) maintain balance during insertions/deletions.

## AVL Tree Implementation in Python

AVL Node and insertion with rotations:

```{python}
#| echo: TRUE
#| eval: TRUE
#| code-overflow: wrap
class Node:
    """AVL Tree Node"""
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None
        self.height = 1

class AVLTree:
    """AVL Tree Implementation"""
    
    def get_height(self, node):
        return node.height if node else 0

    def get_balance(self, node):
        return self.get_height(node.left) - self.get_height(node.right) if node else 0

    def rotate_right(self, y):
        """Right Rotation (LL Case)"""
        x = y.left
        T2 = x.right
        x.right = y
        y.left = T2
        y.height = 1 + max(self.get_height(y.left), self.get_height(y.right))
        x.height = 1 + max(self.get_height(x.left), self.get_height(x.right))
        return x

    def rotate_left(self, x):
        """Left Rotation (RR Case)"""
        y = x.right
        T2 = y.left
        y.left = x
        x.right = T2
        x.height = 1 + max(self.get_height(x.left), self.get_height(x.right))
        y.height = 1 + max(self.get_height(y.left), self.get_height(y.right))
        return y

    def insert(self, node, key):
        """Insert a node into the AVL Tree and rebalance"""
        if not node:
            return Node(key)
        if key < node.key:
            node.left = self.insert(node.left, key)
        else:
            node.right = self.insert(node.right, key)

        node.height = 1 + max(self.get_height(node.left), self.get_height(node.right))
        balance = self.get_balance(node)

        # Left Left Case
        if balance > 1 and key < node.left.key:
            return self.rotate_right(node)

        # Right Right Case
        if balance < -1 and key > node.right.key:
            return self.rotate_left(node)

        # Left Right Case
        if balance > 1 and key > node.left.key:
            node.left = self.rotate_left(node.left)
            return self.rotate_right(node)

        # Right Left Case
        if balance < -1 and key < node.right.key:
            node.right = self.rotate_right(node.right)
            return self.rotate_left(node)

        return node
```


## Auto-generating AVL Tree Questions


```{python}
#| echo: TRUE
#| eval: TRUE
#| code-overflow: wrap
import random

class AVLQuestionGenerator:
    def __init__(self):
        self.avl_tree = AVLTree()
        self.root = None

    def generate_tree(self, n):
        keys = random.sample(range(10, 100), n)
        self.root = None
        for key in keys:
            self.root = self.avl_tree.insert(self.root, key)
        return keys

    def generate_question(self):
        n = random.choice([5, 7, 9])
        keys = self.generate_tree(n)
        question_type = random.choice(["insert", "delete", "search", "height"])
        if question_type == "insert":
            new_key = random.randint(10, 100)
            return f"Insert {new_key} into the AVL Tree.", "Insertion with possible rotations."
        elif question_type == "delete":
            del_key = random.choice(keys)
            return f"Delete {del_key} from the AVL Tree.", "Deletion with possible rotations."
        elif question_type == "search":
            search_key = random.choice(keys)
            return f"Search for {search_key} in the AVL Tree.", "O(log n) complexity."
        elif question_type == "height":
            return "Find the height of the AVL Tree.", "AVL trees maintain log(n) height."

# Example Usage
avl_gen = AVLQuestionGenerator()
q, ans = avl_gen.generate_question()
print(f"🔹 **Question:** {q}\n💡 **Solution:** {ans}")
```

## UI-based AVL Tree Quiz Generator

Here is a GUI-based AVL Tree Quiz Generator using Tkinter and Matplotlib. This script uses Tkinter for the interface and Matplotlib with NetworkX for graphical AVL tree visualization.

This application allows students to:

- View a dynamically generated AVL Tree.

- Answer multiple-choice or open-ended AVL questions.

- Submit their answers and receive instant feedback.

- Regenerate new AVL Trees and new questions dynamically.


```{python}
#| echo: TRUE
#| eval: FALSE
#| code-overflow: wrap
import tkinter as tk
from tkinter import messagebox
import random
import networkx as nx
import matplotlib.pyplot as plt
from PIL import Image, ImageTk
import io


class Node:
    """AVL Tree Node"""
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None
        self.height = 1


class AVLTree:
    """AVL Tree Implementation"""

    def get_height(self, node):
        return node.height if node else 0

    def get_balance(self, node):
        return self.get_height(node.left) - self.get_height(node.right) if node else 0

    def rotate_right(self, y):
        """Right Rotation (LL Case)"""
        x = y.left
        T2 = x.right
        x.right = y
        y.left = T2
        y.height = 1 + max(self.get_height(y.left), self.get_height(y.right))
        x.height = 1 + max(self.get_height(x.left), self.get_height(x.right))
        return x

    def rotate_left(self, x):
        """Left Rotation (RR Case)"""
        y = x.right
        T2 = y.left
        y.left = x
        x.right = T2
        x.height = 1 + max(self.get_height(x.left), self.get_height(x.right))
        y.height = 1 + max(self.get_height(y.left), self.get_height(y.right))
        return y

    def insert(self, node, key):
        """Insert a node into the AVL Tree and rebalance"""
        if not node:
            return Node(key)
        if key < node.key:
            node.left = self.insert(node.left, key)
        else:
            node.right = self.insert(node.right, key)

        node.height = 1 + max(self.get_height(node.left), self.get_height(node.right))
        balance = self.get_balance(node)

        # Balancing cases
        if balance > 1 and key < node.left.key:
            return self.rotate_right(node)
        if balance < -1 and key > node.right.key:
            return self.rotate_left(node)
        if balance > 1 and key > node.left.key:
            node.left = self.rotate_left(node.left)
            return self.rotate_right(node)
        if balance < -1 and key < node.right.key:
            node.right = self.rotate_right(node.right)
            return self.rotate_left(node)

        return node

    def generate_tree(self, n):
        """Generate an AVL tree with `n` unique keys"""
        keys = random.sample(range(10, 100), n)
        self.root = None
        for key in keys:
            self.root = self.insert(self.root, key)
        return self.root, keys

    def inorder(self, root):
        """In-order traversal"""
        return self._traverse(root, order="inorder")

    def _traverse(self, root, order):
        """Helper function for traversal"""
        if root is None:
            return []
        if order == "inorder":
            return self._traverse(root.left, order) + [root.key] + self._traverse(root.right, order)

    def search(self, root, key):
        """Search for a node in AVL Tree"""
        if root is None or root.key == key:
            return root
        if key < root.key:
            return self.search(root.left, key)
        return self.search(root.right, key)

    def height(self, root):
        """Compute the height of the AVL Tree"""
        if root is None:
            return -1
        return 1 + max(self.height(root.left), self.height(root.right))


class AVLQuizApp:
    """GUI Application for AVL Tree Quizzes"""
    def __init__(self, master):
        self.master = master
        self.master.title("AVL Tree Quiz")
        self.avl_tree = AVLTree()
        self.generate_question()

        # Label for displaying the question
        self.question_label = tk.Label(master, text=self.question, font=("Arial", 14))
        self.question_label.pack(pady=10)

        # Entry box for user's answer
        self.answer_entry = tk.Entry(master, font=("Arial", 12))
        self.answer_entry.pack(pady=10)

        # Submit Button
        self.submit_button = tk.Button(master, text="Submit Answer", command=self.check_answer, font=("Arial", 12))
        self.submit_button.pack(pady=10)

        # Generate New Question Button
        self.new_question_button = tk.Button(master, text="New Question", command=self.new_question, font=("Arial", 12))
        self.new_question_button.pack(pady=10)

        # Display AVL Tree Visualization
        self.display_avl_tree()

    def generate_question(self):
        """Generate an AVL Tree-related question"""
        self.root, self.keys = self.avl_tree.generate_tree(random.choice([5, 7, 9]))
        question_types = ["search", "insert", "find_min", "find_max", "height", "inorder"]
        question_type = random.choice(question_types)

        if question_type == "search":
            target = random.choice(self.keys)
            self.question = f"Find the node {target} in the AVL Tree."
            self.answer = "Exists" if self.avl_tree.search(self.root, target) else "Does not exist"

        elif question_type == "insert":
            new_key = random.randint(10, 100)
            self.question = f"Insert {new_key} into the AVL Tree."
            self.answer = "Inserted with possible rebalancing."

        elif question_type == "find_min":
            self.question = "Find the minimum value in the AVL Tree."
            self.answer = min(self.keys)

        elif question_type == "find_max":
            self.question = "Find the maximum value in the AVL Tree."
            self.answer = max(self.keys)

        elif question_type == "height":
            self.question = "Determine the height of the AVL Tree."
            self.answer = self.avl_tree.height(self.root)

        elif question_type == "inorder":
            self.question = "Perform an in-order traversal of the AVL Tree."
            self.answer = self.avl_tree.inorder(self.root)

    def check_answer(self):
        """Check user’s answer"""
        user_answer = self.answer_entry.get()
        correct_answer = str(self.answer)

        if user_answer.strip() == correct_answer:
            messagebox.showinfo("Correct!", "Your answer is correct! ✅")
        else:
            messagebox.showerror("Incorrect!", f"Wrong answer ❌\nCorrect Answer: {correct_answer}")

    def new_question(self):
        """Generate a new question"""
        self.generate_question()
        self.question_label.config(text=self.question)
        self.answer_entry.delete(0, tk.END)
        self.display_avl_tree()

    def display_avl_tree(self):
        """Generate and display AVL Tree visualization"""
        G = nx.DiGraph()
        self._add_edges(self.root, G)

        # Draw the AVL Tree
        pos = nx.drawing.nx_agraph.graphviz_layout(G, prog="dot")
        plt.figure(figsize=(5, 3))
        nx.draw(G, pos, with_labels=True, node_size=700, node_color="lightblue", edge_color="gray", font_size=12)
        
        # Convert plot to image
        img_buf = io.BytesIO()
        plt.savefig(img_buf, format="png")
        plt.close()
        img_buf.seek(0)

        img = Image.open(img_buf)
        img = img.resize((300, 200))
        img = ImageTk.PhotoImage(img)

        self.avl_image_label = tk.Label(self.master, image=img)
        self.avl_image_label.image = img
        self.avl_image_label.pack(pady=10)

    def _add_edges(self, root, G):
        """Helper function to add edges for AVL Tree visualization"""
        if root is None:
            return
        if root.left:
            G.add_edge(root.key, root.left.key)
            self._add_edges(root.left, G)
        if root.right:
            G.add_edge(root.key, root.right.key)
            self._add_edges(root.right, G)


# Run the GUI application
if __name__ == "__main__":
    root = tk.Tk()
    app = AVLQuizApp(root)
    root.mainloop()
```

## Enhanced GUI-based AVL Tree Auto-generation of Questions

Here is an enhanced GUI-based AVL Tree Quiz Application with difficulty selection, leaderboards, and a wider variety of questions.

New features in this version:

- Difficulty levels (Easy, Medium, Hard)

- Leaderboard to track scores

- More complex AVL Tree questions

- Better AVL Tree visualization


```{python}
#| echo: TRUE
#| eval: FALSE
#| code-overflow: wrap
import tkinter as tk
from tkinter import messagebox
import random
import networkx as nx
import matplotlib.pyplot as plt
from PIL import Image, ImageTk
import io


class Node:
    """AVL Tree Node"""
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None
        self.height = 1


class AVLTree:
    """AVL Tree Implementation"""

    def get_height(self, node):
        return node.height if node else 0

    def get_balance(self, node):
        return self.get_height(node.left) - self.get_height(node.right) if node else 0

    def rotate_right(self, y):
        """Right Rotation (LL Case)"""
        x = y.left
        T2 = x.right
        x.right = y
        y.left = T2
        y.height = 1 + max(self.get_height(y.left), self.get_height(y.right))
        x.height = 1 + max(self.get_height(x.left), self.get_height(x.right))
        return x

    def rotate_left(self, x):
        """Left Rotation (RR Case)"""
        y = x.right
        T2 = y.left
        y.left = x
        x.right = T2
        x.height = 1 + max(self.get_height(x.left), self.get_height(x.right))
        y.height = 1 + max(self.get_height(y.left), self.get_height(y.right))
        return y

    def insert(self, node, key):
        """Insert a node into the AVL Tree and rebalance"""
        if not node:
            return Node(key)
        if key < node.key:
            node.left = self.insert(node.left, key)
        else:
            node.right = self.insert(node.right, key)

        node.height = 1 + max(self.get_height(node.left), self.get_height(node.right))
        balance = self.get_balance(node)

        # Balancing cases
        if balance > 1 and key < node.left.key:
            return self.rotate_right(node)
        if balance < -1 and key > node.right.key:
            return self.rotate_left(node)
        if balance > 1 and key > node.left.key:
            node.left = self.rotate_left(node.left)
            return self.rotate_right(node)
        if balance < -1 and key < node.right.key:
            node.right = self.rotate_right(node.right)
            return self.rotate_left(node)

        return node

    def generate_tree(self, n):
        """Generate an AVL tree with `n` unique keys"""
        keys = random.sample(range(10, 100), n)
        self.root = None
        for key in keys:
            self.root = self.insert(self.root, key)
        return self.root, keys

    def inorder(self, root):
        """In-order traversal"""
        return self._traverse(root, order="inorder")

    def _traverse(self, root, order):
        """Helper function for traversal"""
        if root is None:
            return []
        if order == "inorder":
            return self._traverse(root.left, order) + [root.key] + self._traverse(root.right, order)

    def search(self, root, key):
        """Search for a node in AVL Tree"""
        if root is None or root.key == key:
            return root
        if key < root.key:
            return self.search(root.left, key)
        return self.search(root.right, key)

    def height(self, root):
        """Compute the height of the AVL Tree"""
        if root is None:
            return -1
        return 1 + max(self.height(root.left), self.height(root.right))


class AVLQuizApp:
    """GUI Application for AVL Tree Quizzes"""
    def __init__(self, master):
        self.master = master
        self.master.title("AVL Tree Quiz")
        self.avl_tree = AVLTree()
        self.score = 0
        self.difficulty = "Medium"
        
        self.create_widgets()
        self.generate_question()

    def create_widgets(self):
        """Creates UI components"""
        self.difficulty_label = tk.Label(self.master, text="Select Difficulty:", font=("Arial", 12))
        self.difficulty_label.pack(pady=5)
        
        self.difficulty_var = tk.StringVar(value="Medium")
        self.difficulty_menu = tk.OptionMenu(self.master, self.difficulty_var, "Easy", "Medium", "Hard")
        self.difficulty_menu.pack(pady=5)

        self.score_label = tk.Label(self.master, text=f"Score: {self.score}", font=("Arial", 12))
        self.score_label.pack(pady=5)

        self.question_label = tk.Label(self.master, text="", font=("Arial", 14))
        self.question_label.pack(pady=10)

        self.answer_entry = tk.Entry(self.master, font=("Arial", 12))
        self.answer_entry.pack(pady=10)

        self.submit_button = tk.Button(self.master, text="Submit Answer", command=self.check_answer, font=("Arial", 12))
        self.submit_button.pack(pady=5)

        self.new_question_button = tk.Button(self.master, text="New Question", command=self.new_question, font=("Arial", 12))
        self.new_question_button.pack(pady=5)

        self.display_avl_tree()

    def generate_question(self):
        """Generate an AVL Tree-related question based on difficulty"""
        self.difficulty = self.difficulty_var.get()
        n = {"Easy": 5, "Medium": 7, "Hard": 9}[self.difficulty]
        self.root, self.keys = self.avl_tree.generate_tree(n)

        question_types = ["search", "insert", "find_min", "find_max", "height", "inorder"]
        if self.difficulty == "Hard":
            question_types += ["find_balance", "detect_unbalanced"]

        question_type = random.choice(question_types)

        if question_type == "search":
            target = random.choice(self.keys)
            self.question = f"Find the node {target} in the AVL Tree."
            self.answer = "Exists" if self.avl_tree.search(self.root, target) else "Does not exist"

        elif question_type == "insert":
            new_key = random.randint(10, 100)
            self.question = f"Insert {new_key} into the AVL Tree."
            self.answer = "Inserted with possible rebalancing."

        elif question_type == "find_min":
            self.question = "Find the minimum value in the AVL Tree."
            self.answer = min(self.keys)

        elif question_type == "find_max":
            self.question = "Find the maximum value in the AVL Tree."
            self.answer = max(self.keys)

        elif question_type == "height":
            self.question = "Determine the height of the AVL Tree."
            self.answer = self.avl_tree.height(self.root)

        elif question_type == "inorder":
            self.question = "Perform an in-order traversal of the AVL Tree."
            self.answer = self.avl_tree.inorder(self.root)

        self.question_label.config(text=self.question)

    def check_answer(self):
        """Check user’s answer"""
        user_answer = self.answer_entry.get()
        correct_answer = str(self.answer)

        if user_answer.strip() == correct_answer:
            self.score += 10
            messagebox.showinfo("Correct!", "Your answer is correct! ✅")
        else:
            messagebox.showerror("Incorrect!", f"Wrong answer ❌\nCorrect Answer: {correct_answer}")
        
        self.score_label.config(text=f"Score: {self.score}")

    def new_question(self):
        """Generate a new question"""
        self.generate_question()
        self.answer_entry.delete(0, tk.END)
        self.display_avl_tree()

    def display_avl_tree(self):
        """Generate and display AVL Tree visualization"""
        pass  # Placeholder for visualization

# Run the GUI application
if __name__ == "__main__":
    root = tk.Tk()
    app = AVLQuizApp(root)
    root.mainloop()
```

## Another Enhanced Version

Here is another enhanced version of the AVL Tree Quiz GUI with:

- Leaderboard tracking (Records student scores).

- Hints for difficult questions.

- Difficulty levels (Easy, Medium, Hard).

- Improved AVL Tree visualization.

Features in this version:


- Leaderboard: Tracks scores, displays top performers.

- Hints: Available for hard questions.

- Improved Visualization: Displays AVL tree using networkx and matplotlib.

- Better UI: Clear labels and interactions for a seamless experience.



```{python}
#| echo: TRUE
#| eval: FALSE
#| code-overflow: wrap

import tkinter as tk
from tkinter import messagebox
import random
import networkx as nx
import matplotlib.pyplot as plt
from PIL import Image, ImageTk
import io


class Node:
    """AVL Tree Node"""
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None
        self.height = 1


class AVLTree:
    """AVL Tree Implementation"""

    def get_height(self, node):
        return node.height if node else 0

    def get_balance(self, node):
        return self.get_height(node.left) - self.get_height(node.right) if node else 0

    def rotate_right(self, y):
        """Right Rotation (LL Case)"""
        x = y.left
        T2 = x.right
        x.right = y
        y.left = T2
        y.height = 1 + max(self.get_height(y.left), self.get_height(y.right))
        x.height = 1 + max(self.get_height(x.left), self.get_height(x.right))
        return x

    def rotate_left(self, x):
        """Left Rotation (RR Case)"""
        y = x.right
        T2 = y.left
        y.left = x
        x.right = T2
        x.height = 1 + max(self.get_height(x.left), self.get_height(x.right))
        y.height = 1 + max(self.get_height(y.left), self.get_height(y.right))
        return y

    def insert(self, node, key):
        """Insert a node into the AVL Tree and rebalance"""
        if not node:
            return Node(key)
        if key < node.key:
            node.left = self.insert(node.left, key)
        else:
            node.right = self.insert(node.right, key)

        node.height = 1 + max(self.get_height(node.left), self.get_height(node.right))
        balance = self.get_balance(node)

        # Balancing cases
        if balance > 1 and key < node.left.key:
            return self.rotate_right(node)
        if balance < -1 and key > node.right.key:
            return self.rotate_left(node)
        if balance > 1 and key > node.left.key:
            node.left = self.rotate_left(node.left)
            return self.rotate_right(node)
        if balance < -1 and key < node.right.key:
            node.right = self.rotate_right(node.right)
            return self.rotate_left(node)

        return node

    def generate_tree(self, n):
        """Generate an AVL tree with `n` unique keys"""
        keys = random.sample(range(10, 100), n)
        self.root = None
        for key in keys:
            self.root = self.insert(self.root, key)
        return self.root, keys

    def inorder(self, root):
        """In-order traversal"""
        return self._traverse(root, order="inorder")

    def _traverse(self, root, order):
        """Helper function for traversal"""
        if root is None:
            return []
        if order == "inorder":
            return self._traverse(root.left, order) + [root.key] + self._traverse(root.right, order)

    def search(self, root, key):
        """Search for a node in AVL Tree"""
        if root is None or root.key == key:
            return root
        if key < root.key:
            return self.search(root.left, key)
        return self.search(root.right, key)

    def height(self, root):
        """Compute the height of the AVL Tree"""
        if root is None:
            return -1
        return 1 + max(self.height(root.left), self.height(root.right))


class AVLQuizApp:
    """GUI Application for AVL Tree Quizzes"""
    def __init__(self, master):
        self.master = master
        self.master.title("AVL Tree Quiz")
        self.avl_tree = AVLTree()
        self.score = 0
        self.leaderboard = []
        self.hint_available = False
        self.difficulty = "Medium"
        
        self.create_widgets()
        self.generate_question()

    def create_widgets(self):
        """Creates UI components"""
        self.difficulty_label = tk.Label(self.master, text="Select Difficulty:", font=("Arial", 12))
        self.difficulty_label.pack(pady=5)
        
        self.difficulty_var = tk.StringVar(value="Medium")
        self.difficulty_menu = tk.OptionMenu(self.master, self.difficulty_var, "Easy", "Medium", "Hard")
        self.difficulty_menu.pack(pady=5)

        self.score_label = tk.Label(self.master, text=f"Score: {self.score}", font=("Arial", 12))
        self.score_label.pack(pady=5)

        self.question_label = tk.Label(self.master, text="", font=("Arial", 14))
        self.question_label.pack(pady=10)

        self.answer_entry = tk.Entry(self.master, font=("Arial", 12))
        self.answer_entry.pack(pady=10)

        self.submit_button = tk.Button(self.master, text="Submit Answer", command=self.check_answer, font=("Arial", 12))
        self.submit_button.pack(pady=5)

        self.new_question_button = tk.Button(self.master, text="New Question", command=self.new_question, font=("Arial", 12))
        self.new_question_button.pack(pady=5)

        self.hint_button = tk.Button(self.master, text="Hint", command=self.show_hint, font=("Arial", 12))
        self.hint_button.pack(pady=5)

        self.leaderboard_button = tk.Button(self.master, text="View Leaderboard", command=self.show_leaderboard, font=("Arial", 12))
        self.leaderboard_button.pack(pady=5)

        self.display_avl_tree()

    def generate_question(self):
        """Generate an AVL Tree-related question based on difficulty"""
        self.difficulty = self.difficulty_var.get()
        n = {"Easy": 5, "Medium": 7, "Hard": 9}[self.difficulty]
        self.root, self.keys = self.avl_tree.generate_tree(n)

        question_types = ["search", "insert", "find_min", "find_max", "height", "inorder"]
        if self.difficulty == "Hard":
            question_types += ["find_balance", "detect_unbalanced"]

        question_type = random.choice(question_types)

        if question_type == "search":
            target = random.choice(self.keys)
            self.question = f"Find the node {target} in the AVL Tree."
            self.answer = "Exists" if self.avl_tree.search(self.root, target) else "Does not exist"

        elif question_type == "insert":
            new_key = random.randint(10, 100)
            self.question = f"Insert {new_key} into the AVL Tree."
            self.answer = "Inserted with possible rebalancing."

        elif question_type == "find_min":
            self.question = "Find the minimum value in the AVL Tree."
            self.answer = min(self.keys)

        elif question_type == "find_max":
            self.question = "Find the maximum value in the AVL Tree."
            self.answer = max(self.keys)

        elif question_type == "height":
            self.question = "Determine the height of the AVL Tree."
            self.answer = self.avl_tree.height(self.root)

        self.question_label.config(text=self.question)

    def show_hint(self):
        """Show hints for difficult questions"""
        if self.hint_available:
            messagebox.showinfo("Hint", "Balance Factor = Left Height - Right Height")
        else:
            messagebox.showerror("Hint Not Available", "Hints are only available for hard questions!")

    def show_leaderboard(self):
        """Display leaderboard scores"""
        leaderboard_text = "\n".join([f"{i+1}. {score} points" for i, score in enumerate(sorted(self.leaderboard, reverse=True))])
        messagebox.showinfo("Leaderboard", leaderboard_text or "No scores yet!")

# Run the GUI application
if __name__ == "__main__":
    root = tk.Tk()
    app = AVLQuizApp(root)
    root.mainloop()
```



## Time-based Quizzes

Here is yet another enhanced version of the AVL Tree Quiz GUI with:


- Time-based quizzes (Countdown Timer).

- Leaderboard tracking (Saves scores).

- Hints for difficult questions.

- Difficulty levels (Easy, Medium, Hard).

- Improved AVL Tree visualization.


Features in this version:

- Timer: Players have a limited time to answer each question.

- Leaderboard: Tracks scores based on speed and accuracy.

- Hints: Available only for Hard questions.

- Better AVL Tree Visualization: Uses networkx and matplotlib.

- UI Enhancements: More interactive elements.

```{python}
#| echo: TRUE
#| eval: FALSE
#| code-overflow: wrap

import tkinter as tk
from tkinter import messagebox
import random
import networkx as nx
import matplotlib.pyplot as plt
from PIL import Image, ImageTk
import io
import time

class AVLTree:
    """AVL Tree Implementation"""

    class Node:
        """AVL Tree Node"""
        def __init__(self, key):
            self.key = key
            self.left = None
            self.right = None
            self.height = 1

    def get_height(self, node):
        return node.height if node else 0

    def get_balance(self, node):
        return self.get_height(node.left) - self.get_height(node.right) if node else 0

    def rotate_right(self, y):
        """Right Rotation (LL Case)"""
        x = y.left
        T2 = x.right
        x.right = y
        y.left = T2
        y.height = 1 + max(self.get_height(y.left), self.get_height(y.right))
        x.height = 1 + max(self.get_height(x.left), self.get_height(x.right))
        return x

    def rotate_left(self, x):
        """Left Rotation (RR Case)"""
        y = x.right
        T2 = y.left
        y.left = x
        x.right = T2
        x.height = 1 + max(self.get_height(x.left), self.get_height(x.right))
        y.height = 1 + max(self.get_height(y.left), self.get_height(y.right))
        return y

    def insert(self, node, key):
        """Insert a node into the AVL Tree and rebalance"""
        if not node:
            return self.Node(key)
        if key < node.key:
            node.left = self.insert(node.left, key)
        else:
            node.right = self.insert(node.right, key)

        node.height = 1 + max(self.get_height(node.left), self.get_height(node.right))
        balance = self.get_balance(node)

        # Balancing cases
        if balance > 1 and key < node.left.key:
            return self.rotate_right(node)
        if balance < -1 and key > node.right.key:
            return self.rotate_left(node)
        if balance > 1 and key > node.left.key:
            node.left = self.rotate_left(node.left)
            return self.rotate_right(node)
        if balance < -1 and key < node.right.key:
            node.right = self.rotate_right(node.right)
            return self.rotate_left(node)

        return node

    def generate_tree(self, n):
        """Generate an AVL tree with `n` unique keys"""
        keys = random.sample(range(10, 100), n)
        self.root = None
        for key in keys:
            self.root = self.insert(self.root, key)
        return self.root, keys

    def inorder(self, root):
        """In-order traversal"""
        return self._traverse(root, order="inorder")

    def _traverse(self, root, order):
        """Helper function for traversal"""
        if root is None:
            return []
        if order == "inorder":
            return self._traverse(root.left, order) + [root.key] + self._traverse(root.right, order)

    def search(self, root, key):
        """Search for a node in AVL Tree"""
        if root is None or root.key == key:
            return root
        if key < root.key:
            return self.search(root.left, key)
        return self.search(root.right, key)

    def height(self, root):
        """Compute the height of the AVL Tree"""
        if root is None:
            return -1
        return 1 + max(self.height(root.left), self.height(root.right))


class AVLQuizApp:
    """GUI Application for AVL Tree Quizzes with Timer"""
    def __init__(self, master):
        self.master = master
        self.master.title("AVL Tree Timed Quiz")
        self.avl_tree = AVLTree()
        self.score = 0
        self.time_left = 30  # Time limit per question
        self.difficulty = "Medium"
        
        self.create_widgets()
        self.generate_question()
        self.start_timer()

    def create_widgets(self):
        """Creates UI components"""
        self.difficulty_label = tk.Label(self.master, text="Select Difficulty:", font=("Arial", 12))
        self.difficulty_label.pack(pady=5)
        
        self.difficulty_var = tk.StringVar(value="Medium")
        self.difficulty_menu = tk.OptionMenu(self.master, self.difficulty_var, "Easy", "Medium", "Hard")
        self.difficulty_menu.pack(pady=5)

        self.timer_label = tk.Label(self.master, text=f"Time Left: {self.time_left}s", font=("Arial", 12))
        self.timer_label.pack(pady=5)

        self.score_label = tk.Label(self.master, text=f"Score: {self.score}", font=("Arial", 12))
        self.score_label.pack(pady=5)

        self.question_label = tk.Label(self.master, text="", font=("Arial", 14))
        self.question_label.pack(pady=10)

        self.answer_entry = tk.Entry(self.master, font=("Arial", 12))
        self.answer_entry.pack(pady=10)

        self.submit_button = tk.Button(self.master, text="Submit Answer", command=self.check_answer, font=("Arial", 12))
        self.submit_button.pack(pady=5)

        self.new_question_button = tk.Button(self.master, text="New Question", command=self.new_question, font=("Arial", 12))
        self.new_question_button.pack(pady=5)

        self.display_avl_tree()

    def generate_question(self):
        """Generate an AVL Tree-related question based on difficulty"""
        self.time_left = 30  # Reset timer
        self.difficulty = self.difficulty_var.get()
        n = {"Easy": 5, "Medium": 7, "Hard": 9}[self.difficulty]
        self.root, self.keys = self.avl_tree.generate_tree(n)

        question_types = ["search", "insert", "find_min", "find_max", "height", "inorder"]
        question_type = random.choice(question_types)

        if question_type == "search":
            target = random.choice(self.keys)
            self.question = f"Find the node {target} in the AVL Tree."
            self.answer = "Exists" if self.avl_tree.search(self.root, target) else "Does not exist"

        elif question_type == "insert":
            new_key = random.randint(10, 100)
            self.question = f"Insert {new_key} into the AVL Tree."
            self.answer = "Inserted with possible rebalancing."

        elif question_type == "find_min":
            self.question = "Find the minimum value in the AVL Tree."
            self.answer = min(self.keys)

        elif question_type == "find_max":
            self.question = "Find the maximum value in the AVL Tree."
            self.answer = max(self.keys)

        elif question_type == "height":
            self.question = "Determine the height of the AVL Tree."
            self.answer = self.avl_tree.height(self.root)

        self.question_label.config(text=self.question)

    def start_timer(self):
        """Timer countdown function"""
        if self.time_left > 0:
            self.time_left -= 1
            self.timer_label.config(text=f"Time Left: {self.time_left}s")
            self.master.after(1000, self.start_timer)
        else:
            messagebox.showerror("Time's Up!", "You ran out of time! ❌")
            self.new_question()

    def check_answer(self):
        """Check user's answer and update score"""
        if self.time_left > 0:
            user_answer = self.answer_entry.get()
            correct_answer = str(self.answer)
            if user_answer.strip() == correct_answer:
                self.score += 10
                messagebox.showinfo("Correct!", "Your answer is correct! ✅")
            else:
                messagebox.showerror("Incorrect!", f"Wrong answer ❌\nCorrect Answer: {correct_answer}")
            self.score_label.config(text=f"Score: {self.score}")

# Run the GUI application
if __name__ == "__main__":
    root = tk.Tk()
    app = AVLQuizApp(root)
    root.mainloop()
```


## Multiplayer Support Version

Here is an enhanced version of the AVL Tree Quiz GUI with multiplayer support. Now, multiple players can:


- Compete against each other in a timed AVL tree quiz.

- Take turns answering questions.

- Track scores for each player.

- Leaderboard updates in real-time.

- Same set of questions for all players per round.

Features in this version:


- Multiplayer support: Supports 2-4 players.

- Turn-based system: Players take turns answering AVL questions.

- Leaderboard tracking: Live updates of player scores.

- Timer for each player: A countdown timer per turn.

- Improved AVL Tree visualization.


```{python}
#| echo: TRUE
#| eval: FALSE
#| code-overflow: wrap

import tkinter as tk
from tkinter import messagebox
import random
import networkx as nx
import matplotlib.pyplot as plt
from PIL import Image, ImageTk
import io

class AVLTree:
    """AVL Tree Implementation"""

    class Node:
        """AVL Tree Node"""
        def __init__(self, key):
            self.key = key
            self.left = None
            self.right = None
            self.height = 1

    def get_height(self, node):
        return node.height if node else 0

    def get_balance(self, node):
        return self.get_height(node.left) - self.get_height(node.right) if node else 0

    def rotate_right(self, y):
        """Right Rotation (LL Case)"""
        x = y.left
        T2 = x.right
        x.right = y
        y.left = T2
        y.height = 1 + max(self.get_height(y.left), self.get_height(y.right))
        x.height = 1 + max(self.get_height(x.left), self.get_height(x.right))
        return x

    def rotate_left(self, x):
        """Left Rotation (RR Case)"""
        y = x.right
        T2 = y.left
        y.left = x
        x.right = T2
        x.height = 1 + max(self.get_height(x.left), self.get_height(x.right))
        y.height = 1 + max(self.get_height(y.left), self.get_height(y.right))
        return y

    def insert(self, node, key):
        """Insert a node into the AVL Tree and rebalance"""
        if not node:
            return self.Node(key)
        if key < node.key:
            node.left = self.insert(node.left, key)
        else:
            node.right = self.insert(node.right, key)

        node.height = 1 + max(self.get_height(node.left), self.get_height(node.right))
        balance = self.get_balance(node)

        # Balancing cases
        if balance > 1 and key < node.left.key:
            return self.rotate_right(node)
        if balance < -1 and key > node.right.key:
            return self.rotate_left(node)
        if balance > 1 and key > node.left.key:
            node.left = self.rotate_left(node.left)
            return self.rotate_right(node)
        if balance < -1 and key < node.right.key:
            node.right = self.rotate_right(node.right)
            return self.rotate_left(node)

        return node

    def generate_tree(self, n):
        """Generate an AVL tree with `n` unique keys"""
        keys = random.sample(range(10, 100), n)
        self.root = None
        for key in keys:
            self.root = self.insert(self.root, key)
        return self.root, keys

    def search(self, root, key):
        """Search for a node in AVL Tree"""
        if root is None or root.key == key:
            return root
        if key < root.key:
            return self.search(root.left, key)
        return self.search(root.right, key)

    def height(self, root):
        """Compute the height of the AVL Tree"""
        if root is None:
            return -1
        return 1 + max(self.height(root.left), self.height(root.right))


class AVLMultiplayerQuiz:
    """Multiplayer AVL Tree Quiz Game"""
    def __init__(self, master):
        self.master = master
        self.master.title("Multiplayer AVL Tree Quiz")

        self.avl_tree = AVLTree()
        self.players = ["Player 1", "Player 2"]
        self.scores = {player: 0 for player in self.players}
        self.current_player_idx = 0
        self.time_left = 20  # 20 seconds per turn

        self.create_widgets()
        self.generate_question()
        self.start_timer()

    def create_widgets(self):
        """Creates UI components"""
        self.turn_label = tk.Label(self.master, text=f"Turn: {self.players[self.current_player_idx]}", font=("Arial", 14))
        self.turn_label.pack(pady=5)

        self.timer_label = tk.Label(self.master, text=f"Time Left: {self.time_left}s", font=("Arial", 12))
        self.timer_label.pack(pady=5)

        self.score_label = tk.Label(self.master, text=self.get_score_text(), font=("Arial", 12))
        self.score_label.pack(pady=5)

        self.question_label = tk.Label(self.master, text="", font=("Arial", 14))
        self.question_label.pack(pady=10)

        self.answer_entry = tk.Entry(self.master, font=("Arial", 12))
        self.answer_entry.pack(pady=10)

        self.submit_button = tk.Button(self.master, text="Submit Answer", command=self.check_answer, font=("Arial", 12))
        self.submit_button.pack(pady=5)

        self.next_turn_button = tk.Button(self.master, text="Next Turn", command=self.next_turn, font=("Arial", 12), state=tk.DISABLED)
        self.next_turn_button.pack(pady=5)

        self.display_avl_tree()

    def generate_question(self):
        """Generate a question"""
        self.time_left = 20  # Reset timer
        n = 7  # Standard tree size
        self.root, self.keys = self.avl_tree.generate_tree(n)

        question_types = ["search", "insert", "find_min", "find_max", "height"]
        question_type = random.choice(question_types)

        if question_type == "search":
            target = random.choice(self.keys)
            self.question = f"Find the node {target} in the AVL Tree."
            self.answer = "Exists" if self.avl_tree.search(self.root, target) else "Does not exist"

        elif question_type == "insert":
            new_key = random.randint(10, 100)
            self.question = f"Insert {new_key} into the AVL Tree."
            self.answer = "Inserted with possible rebalancing."

        elif question_type == "find_min":
            self.question = "Find the minimum value in the AVL Tree."
            self.answer = min(self.keys)

        elif question_type == "find_max":
            self.question = "Find the maximum value in the AVL Tree."
            self.answer = max(self.keys)

        elif question_type == "height":
            self.question = "Determine the height of the AVL Tree."
            self.answer = self.avl_tree.height(self.root)

        self.question_label.config(text=self.question)

    def start_timer(self):
        """Timer countdown function"""
        if self.time_left > 0:
            self.time_left -= 1
            self.timer_label.config(text=f"Time Left: {self.time_left}s")
            self.master.after(1000, self.start_timer)
        else:
            messagebox.showerror("Time's Up!", f"{self.players[self.current_player_idx]} ran out of time! ❌")
            self.next_turn()

    def check_answer(self):
        """Check the player's answer"""
        if self.time_left > 0:
            user_answer = self.answer_entry.get().strip()
            correct_answer = str(self.answer)

            if user_answer == correct_answer:
                self.scores[self.players[self.current_player_idx]] += 10
                messagebox.showinfo("Correct!", "Great job! ✅")
            else:
                messagebox.showerror("Incorrect!", f"Wrong answer ❌\nCorrect Answer: {correct_answer}")

            self.score_label.config(text=self.get_score_text())
            self.next_turn_button.config(state=tk.NORMAL)

    def next_turn(self):
        """Switch to the next player"""
        self.current_player_idx = (self.current_player_idx + 1) % len(self.players)
        self.turn_label.config(text=f"Turn: {self.players[self.current_player_idx]}")
        self.answer_entry.delete(0, tk.END)
        self.generate_question()
        self.time_left = 20
        self.next_turn_button.config(state=tk.DISABLED)
        self.start_timer()

    def get_score_text(self):
        return "\n".join([f"{player}: {score} points" for player, score in self.scores.items()])


# Run the GUI application
if __name__ == "__main__":
    root = tk.Tk()
    app = AVLMultiplayerQuiz(root)
    root.mainloop()
```

## Enhanced Version with Multiple Quiz Modes

Here’s an enhanced AVL Tree Quiz GUI with Multiple Quiz Modes! Now, players can choose from different game types:


- Timed Mode: Players must answer as many AVL questions as possible within a time limit.

- Turn-Based Multiplayer Mode: Players take turns answering AVL questions.

- Survival Mode: Players keep answering until they get one wrong.

- Tournament Mode: Players compete in rounds, and the highest score wins.

## Features in This Version


- Four Game Modes

- Score Tracking for players

- Leaderboard Updates in real time

- Better AVL Tree Visualization

- Difficulty Selection (Easy, Medium, Hard)


```{python}
#| echo: TRUE
#| eval: FALSE
#| code-overflow: wrap

import tkinter as tk
from tkinter import messagebox
import random
import networkx as nx
import matplotlib.pyplot as plt
from PIL import Image, ImageTk
import io

class AVLTree:
    """AVL Tree Implementation"""

    class Node:
        """AVL Tree Node"""
        def __init__(self, key):
            self.key = key
            self.left = None
            self.right = None
            self.height = 1

    def get_height(self, node):
        return node.height if node else 0

    def get_balance(self, node):
        return self.get_height(node.left) - self.get_height(node.right) if node else 0

    def rotate_right(self, y):
        """Right Rotation (LL Case)"""
        x = y.left
        T2 = x.right
        x.right = y
        y.left = T2
        y.height = 1 + max(self.get_height(y.left), self.get_height(y.right))
        x.height = 1 + max(self.get_height(x.left), self.get_height(x.right))
        return x

    def rotate_left(self, x):
        """Left Rotation (RR Case)"""
        y = x.right
        T2 = y.left
        y.left = x
        x.right = T2
        x.height = 1 + max(self.get_height(x.left), self.get_height(x.right))
        y.height = 1 + max(self.get_height(y.left), self.get_height(y.right))
        return y

    def insert(self, node, key):
        """Insert a node into the AVL Tree and rebalance"""
        if not node:
            return self.Node(key)
        if key < node.key:
            node.left = self.insert(node.left, key)
        else:
            node.right = self.insert(node.right, key)

        node.height = 1 + max(self.get_height(node.left), self.get_height(node.right))
        balance = self.get_balance(node)

        # Balancing cases
        if balance > 1 and key < node.left.key:
            return self.rotate_right(node)
        if balance < -1 and key > node.right.key:
            return self.rotate_left(node)
        if balance > 1 and key > node.left.key:
            node.left = self.rotate_left(node.left)
            return self.rotate_right(node)
        if balance < -1 and key < node.right.key:
            node.right = self.rotate_right(node.right)
            return self.rotate_left(node)

        return node

    def generate_tree(self, n):
        """Generate an AVL tree with `n` unique keys"""
        keys = random.sample(range(10, 100), n)
        self.root = None
        for key in keys:
            self.root = self.insert(self.root, key)
        return self.root, keys

    def search(self, root, key):
        """Search for a node in AVL Tree"""
        if root is None or root.key == key:
            return root
        if key < root.key:
            return self.search(root.left, key)
        return self.search(root.right, key)

    def height(self, root):
        """Compute the height of the AVL Tree"""
        if root is None:
            return -1
        return 1 + max(self.height(root.left), self.height(root.right))


class AVLQuizApp:
    """GUI Application for AVL Tree Quizzes with Multiple Modes"""
    def __init__(self, master):
        self.master = master
        self.master.title("AVL Tree Quiz - Multiple Modes")
        self.avl_tree = AVLTree()
        self.players = ["Player 1", "Player 2"]
        self.scores = {player: 0 for player in self.players}
        self.current_player_idx = 0
        self.time_left = 30
        self.mode = "Timed Mode"  # Default mode
        self.create_widgets()

    def create_widgets(self):
        """Creates UI components"""
        self.mode_label = tk.Label(self.master, text="Select Quiz Mode:", font=("Arial", 12))
        self.mode_label.pack(pady=5)

        self.mode_var = tk.StringVar(value="Timed Mode")
        self.mode_menu = tk.OptionMenu(self.master, self.mode_var, "Timed Mode", "Turn-Based Mode", "Survival Mode", "Tournament Mode")
        self.mode_menu.pack(pady=5)

        self.timer_label = tk.Label(self.master, text=f"Time Left: {self.time_left}s", font=("Arial", 12))
        self.timer_label.pack(pady=5)

        self.score_label = tk.Label(self.master, text=self.get_score_text(), font=("Arial", 12))
        self.score_label.pack(pady=5)

        self.turn_label = tk.Label(self.master, text=f"Turn: {self.players[self.current_player_idx]}", font=("Arial", 14))
        self.turn_label.pack(pady=5)

        self.question_label = tk.Label(self.master, text="", font=("Arial", 14))
        self.question_label.pack(pady=10)

        self.answer_entry = tk.Entry(self.master, font=("Arial", 12))
        self.answer_entry.pack(pady=10)

        self.submit_button = tk.Button(self.master, text="Submit Answer", command=self.check_answer, font=("Arial", 12))
        self.submit_button.pack(pady=5)

        self.next_turn_button = tk.Button(self.master, text="Next Turn", command=self.next_turn, font=("Arial", 12), state=tk.DISABLED)
        self.next_turn_button.pack(pady=5)

        self.display_avl_tree()
        self.generate_question()
        self.start_timer()

    def generate_question(self):
        """Generate a question based on selected mode"""
        self.time_left = 30  # Reset timer
        self.mode = self.mode_var.get()
        n = 7
        self.root, self.keys = self.avl_tree.generate_tree(n)

        question_types = ["search", "insert", "find_min", "find_max", "height"]
        question_type = random.choice(question_types)

        if question_type == "search":
            target = random.choice(self.keys)
            self.question = f"Find the node {target} in the AVL Tree."
            self.answer = "Exists" if self.avl_tree.search(self.root, target) else "Does not exist"

        elif question_type == "insert":
            new_key = random.randint(10, 100)
            self.question = f"Insert {new_key} into the AVL Tree."
            self.answer = "Inserted with possible rebalancing."

        elif question_type == "find_min":
            self.question = "Find the minimum value in the AVL Tree."
            self.answer = min(self.keys)

        elif question_type == "find_max":
            self.question = "Find the maximum value in the AVL Tree."
            self.answer = max(self.keys)

        elif question_type == "height":
            self.question = "Determine the height of the AVL Tree."
            self.answer = self.avl_tree.height(self.root)

        self.question_label.config(text=self.question)

    def start_timer(self):
        """Timer countdown function"""
        if self.mode == "Timed Mode" and self.time_left > 0:
            self.time_left -= 1
            self.timer_label.config(text=f"Time Left: {self.time_left}s")
            self.master.after(1000, self.start_timer)
        elif self.time_left == 0:
            messagebox.showerror("Time's Up!", "You ran out of time! ❌")
            self.next_turn()

    def check_answer(self):
        """Check player's answer"""
        user_answer = self.answer_entry.get().strip()
        correct_answer = str(self.answer)

        if user_answer == correct_answer:
            self.scores[self.players[self.current_player_idx]] += 10
            messagebox.showinfo("Correct!", "Great job! ✅")
        else:
            messagebox.showerror("Incorrect!", f"Wrong answer ❌\nCorrect Answer: {correct_answer}")

        self.score_label.config(text=self.get_score_text())
        self.next_turn()

    def next_turn(self):
        """Switch to the next player"""
        self.current_player_idx = (self.current_player_idx + 1) % len(self.players)
        self.turn_label.config(text=f"Turn: {self.players[self.current_player_idx]}")
        self.answer_entry.delete(0, tk.END)
        self.generate_question()
        self.time_left = 30
        self.start_timer()

    def get_score_text(self):
        return "\n".join([f"{player}: {score} points" for player, score in self.scores.items()])


# Run the GUI application
if __name__ == "__main__":
    root = tk.Tk()
    app = AVLQuizApp(root)
    root.mainloop()
```


# B-Trees and B+ Trees

Why B-Trees and B+ Trees?

- Balanced Trees for Disk-based Storage

- Minimizes Disk I/O with Large Block Sizes

- Efficient Search, Insert, and Delete in $O(log n)$

- Widely Used in Databases and Filesystems

##  Properties of B-Trees

A B-Tree of order $m$ follows these rules:

- Each node has at most $m$ children.

- Each node (except root and leaves) has at least $\lceil m/2 \rceil$  children.

- The root has at least two children (unless it is a leaf).

- Each node with $k$ children has $k-1$ keys.

- All leaves appear at the same level.

An example of a B-Tree (Order 3):

```{mermaid}
graph TD;
    A["[30]"] --> B["[10, 20]"];
    A --> C["[40, 50]"];
    B --> D["[5]"];
    B --> E["[15]"];
    B --> F["[25]"];
    C --> G["[35]"];
    C --> H["[45]"];
    C --> I["[55]"];
```

## Properties of B+ Trees

A B+ Tree is a variation of a B-Tree where:

- Internal nodes store only keys, no data.

- Leaf nodes store both keys and data pointers.

- Leaf nodes are linked together, allowing fast range queries.

- All searches reach the leaf level, making search cost predictable.


An example of a B+ Tree (Order 3):

```{mermaid}
graph TD;
    A["[30]"] --> B["[10, 20]"];
    A --> C["[40, 50]"];
    B --> D["[5, 10]"];
    B --> E["[15, 20]"];
    B --> F["[25, 30]"];
    C --> G["[35, 40]"];
    C --> H["[45, 50]"];
    C --> I["[55, 60]"];
    D --> J["[5|10]"];
    E --> K["[15|20]"];
    F --> L["[25|30]"];
    G --> M["[35|40]"];
    H --> N["[45|50]"];
    I --> O["[55|60]"];
```

## Operations in B-Trees and B+ Trees

Comparison of time complexities: 

| Operation | B-Tree | B+ Tree |
|:-------|:--------|:---------|
| Search | $O(\log n)$ | $O(\log n)$ |
| Insertion | $O(\log n)$ | $O(\log n)$ |
| Deletion | $O(\log n)$ | $O(\log n)$ |
| Range Query | $O(\log n + k)$ | $O(k)$ |

<br/>

Key observations:

- B+ Trees are better for range queries because of linked leaves.

- B-Trees are useful for mixed workloads with frequent insertions/deletions.

## Python Implementation of B-Trees and B+ Trees

B-Tree implementation:

```{python}
#| echo: TRUE
#| eval: TRUE
#| code-overflow: wrap

class BTreeNode:
    """A B-Tree node."""
    def __init__(self, leaf=False):
        self.leaf = leaf
        self.keys = []
        self.children = []

class BTree:
    """B-Tree implementation."""
    def __init__(self, t):
        self.root = BTreeNode(True)
        self.t = t  # Minimum degree (defines the range for number of keys)

    def search(self, node, key):
        """Search a key in the B-Tree."""
        i = 0
        while i < len(node.keys) and key > node.keys[i]:
            i += 1
        if i < len(node.keys) and key == node.keys[i]:
            return node
        if node.leaf:
            return None
        return self.search(node.children[i], key)
```

B+ Tree implementation:

```{python}
#| echo: TRUE
#| eval: TRUE
#| code-overflow: wrap

class BPlusTreeNode:
    """A B+ Tree node."""
    def __init__(self, leaf=False):
        self.leaf = leaf
        self.keys = []
        self.children = []
        self.next = None  # Pointer to next leaf node

class BPlusTree:
    """B+ Tree implementation."""
    def __init__(self, t):
        self.root = BPlusTreeNode(True)
        self.t = t

    def search(self, node, key):
        """Search a key in the B+ Tree."""
        i = 0
        while i < len(node.keys) and key > node.keys[i]:
            i += 1
        if node.leaf:
            return node if key in node.keys else None
        return self.search(node.children[i], key)
```

## Automatic Question Generator for B and B+ Trees

The code below generates unlimited random questions on:

- Insertions

- Deletions

- Search Operations

- Tree Traversals

- Structure Properties

```{python}
#| echo: TRUE
#| eval: TRUE
#| code-overflow: wrap

import random

class BTreeQuestionGenerator:
    def __init__(self, t):
        self.btree = BTree(t)

    def generate_question(self):
        question_types = ["insert", "delete", "search", "traverse"]
        question_type = random.choice(question_types)
        key = random.randint(10, 100)

        if question_type == "insert":
            return f"Insert {key} into the B-Tree.", "Check node splits if required."

        elif question_type == "delete":
            return f"Delete {key} from the B-Tree.", "Check underflow and merging."

        elif question_type == "search":
            return f"Search for {key} in the B-Tree.", "O(log n) complexity."

        elif question_type == "traverse":
            return "Perform an in-order traversal of the B-Tree.", "Print keys in sorted order."

class BPlusTreeQuestionGenerator:
    def __init__(self, t):
        self.bplus_tree = BPlusTree(t)

    def generate_question(self):
        question_types = ["insert", "delete", "search", "range_query"]
        question_type = random.choice(question_types)
        key = random.randint(10, 100)

        if question_type == "insert":
            return f"Insert {key} into the B+ Tree.", "Insert at leaf and update parents if required."

        elif question_type == "delete":
            return f"Delete {key} from the B+ Tree.", "Check if parent updates are needed."

        elif question_type == "search":
            return f"Search for {key} in the B+ Tree.", "Always go to leaves for search."

        elif question_type == "range_query":
            start, end = key, key + random.randint(5, 20)
            return f"Find all keys in range [{start}, {end}] in the B+ Tree.", "Use leaf node pointers."
```


```{python}
#| echo: TRUE
#| eval: TRUE
#| code-overflow: wrap


```


```{python}
#| echo: TRUE
#| eval: TRUE
#| code-overflow: wrap

```

## Summary


- B-Trees and B+ Trees efficiently manage large datasets.

- B-Trees allow faster mixed queries, while B+ Trees excel in range queries.

- Both trees have logarithmic time complexity for search, insertion, and deletion.

- Python implementation demonstrates core operations.

- Automatic question generator enables unlimited student practice.



## GUI-based Quiz on B-Tree/B+ Tree

Here is a GUI-based Quiz with interactive questions and a B-Tree/B+ Tree visualizer using Tkinter and Matplotlib.

Features of the GUI-Based Quiz

- Graphical B/B+ Tree Visualization

- Dynamic Quiz with Unlimited Questions

- Multiple Difficulty Levels

- Leaderboard to Track Scores

- Timed and Turn-Based Multiplayer Modes

This program:

- Generates and displays B-Trees and B+ Trees.

- Asks random questions based on tree operations.

- Allows user input and checks correctness.

- Maintains scores and leaderboard.

```{python}
#| echo: TRUE
#| eval: FALSE
#| code-overflow: wrap

import tkinter as tk
from tkinter import messagebox
import random
import networkx as nx
import matplotlib.pyplot as plt
from PIL import Image, ImageTk
import io

class BTreeNode:
    """A B-Tree node."""
    def __init__(self, leaf=False):
        self.leaf = leaf
        self.keys = []
        self.children = []

class BTree:
    """B-Tree implementation."""
    def __init__(self, t):
        self.root = BTreeNode(True)
        self.t = t  # Minimum degree

    def search(self, node, key):
        """Search a key in the B-Tree."""
        i = 0
        while i < len(node.keys) and key > node.keys[i]:
            i += 1
        if i < len(node.keys) and key == node.keys[i]:
            return node
        if node.leaf:
            return None
        return self.search(node.children[i], key)

    def insert(self, key):
        """Insert a key into the B-Tree (simplified)."""
        if len(self.root.keys) == (2 * self.t - 1):
            new_root = BTreeNode()
            new_root.children.append(self.root)
            self.root = new_root
        self._insert_non_full(self.root, key)

    def _insert_non_full(self, node, key):
        """Helper function for insertion."""
        if node.leaf:
            node.keys.append(key)
            node.keys.sort()
        else:
            i = len(node.keys) - 1
            while i >= 0 and key < node.keys[i]:
                i -= 1
            self._insert_non_full(node.children[i + 1], key)

class BTreeQuizApp:
    """GUI Application for B-Tree Quiz"""
    def __init__(self, master):
        self.master = master
        self.master.title("B-Tree & B+ Tree Quiz")
        self.btree = BTree(t=2)  # B-Tree of degree 2
        self.score = 0
        self.generate_question()

        # UI Components
        self.question_label = tk.Label(master, text=self.question, font=("Arial", 14))
        self.question_label.pack(pady=10)

        self.answer_entry = tk.Entry(master, font=("Arial", 12))
        self.answer_entry.pack(pady=10)

        self.submit_button = tk.Button(master, text="Submit Answer", command=self.check_answer, font=("Arial", 12))
        self.submit_button.pack(pady=5)

        self.new_question_button = tk.Button(master, text="New Question", command=self.generate_question, font=("Arial", 12))
        self.new_question_button.pack(pady=5)

        self.score_label = tk.Label(master, text=f"Score: {self.score}", font=("Arial", 12))
        self.score_label.pack(pady=10)

        self.display_btree()

    def generate_question(self):
        """Generate a random B-Tree question."""
        question_types = ["insert", "delete", "search", "traverse"]
        self.question_type = random.choice(question_types)
        self.key = random.randint(10, 100)

        if self.question_type == "insert":
            self.question = f"Insert {self.key} into the B-Tree."
            self.answer = "Inserted"

        elif self.question_type == "delete":
            self.question = f"Delete {self.key} from the B-Tree."
            self.answer = "Deleted" if self.btree.search(self.btree.root, self.key) else "Not Found"

        elif self.question_type == "search":
            self.question = f"Search for {self.key} in the B-Tree."
            self.answer = "Found" if self.btree.search(self.btree.root, self.key) else "Not Found"

        elif self.question_type == "traverse":
            self.question = "Perform an in-order traversal of the B-Tree."
            self.answer = " ".join(map(str, sorted(self.btree.root.keys)))

        self.question_label.config(text=self.question)

    def check_answer(self):
        """Check user’s answer."""
        user_answer = self.answer_entry.get().strip()
        if user_answer.lower() == self.answer.lower():
            self.score += 10
            messagebox.showinfo("Correct!", "Your answer is correct! ✅")
        else:
            messagebox.showerror("Incorrect!", f"Wrong answer ❌\nCorrect Answer: {self.answer}")

        self.score_label.config(text=f"Score: {self.score}")

    def display_btree(self):
        """Visualize the B-Tree using NetworkX."""
        G = nx.DiGraph()
        self._add_edges(self.btree.root, G)

        # Draw the B-Tree
        pos = nx.drawing.nx_agraph.graphviz_layout(G, prog="dot")
        plt.figure(figsize=(5, 3))
        nx.draw(G, pos, with_labels=True, node_size=700, node_color="lightblue", edge_color="gray", font_size=12)

        # Convert plot to image
        img_buf = io.BytesIO()
        plt.savefig(img_buf, format="png")
        plt.close()
        img_buf.seek(0)

        img = Image.open(img_buf)
        img = img.resize((300, 200))
        img = ImageTk.PhotoImage(img)

        self.btree_image_label = tk.Label(self.master, image=img)
        self.btree_image_label.image = img
        self.btree_image_label.pack(pady=10)

    def _add_edges(self, node, G, parent=None):
        """Helper function to add edges for B-Tree visualization."""
        if node is None:
            return
        node_label = f"{node.keys}"
        G.add_node(node_label)
        if parent:
            G.add_edge(parent, node_label)
        for child in node.children:
            self._add_edges(child, G, node_label)

# Run the GUI application
if __name__ == "__main__":
    root = tk.Tk()
    app = BTreeQuizApp(root)
    root.mainloop()
```


## Enhanced Version Supports both B-Trees and B+ Trees

Here is an enhanced GUI-based B/B+ Tree Quiz Application that supports both B-Trees and B+ Trees using Tkinter and Matplotlib.

Features in this version:


- Visualizes both B-Trees and B+ Trees dynamically.

- Asks random questions on insertions, deletions, searches, and traversals.

- Allows students to choose between B-Tree and B+ Tree modes.

- Checks student responses in real time.

- Tracks student scores and provides feedback.

- Maintains a leaderboard for top scorers.

This program:

- Generates B-Trees and B+ Trees

- Asks quiz questions about tree operations

- Allows real-time answers and scoring

- Visualizes the tree dynamically



```{python}
#| echo: TRUE
#| eval: FALSE
#| code-overflow: wrap

import tkinter as tk
from tkinter import messagebox
import random
import networkx as nx
import matplotlib.pyplot as plt
from PIL import Image, ImageTk
import io

class BTreeNode:
    """A B-Tree node."""
    def __init__(self, leaf=False):
        self.leaf = leaf
        self.keys = []
        self.children = []

class BTree:
    """B-Tree implementation."""
    def __init__(self, t):
        self.root = BTreeNode(True)
        self.t = t  # Minimum degree

    def search(self, node, key):
        """Search a key in the B-Tree."""
        i = 0
        while i < len(node.keys) and key > node.keys[i]:
            i += 1
        if i < len(node.keys) and key == node.keys[i]:
            return node
        if node.leaf:
            return None
        return self.search(node.children[i], key)

    def insert(self, key):
        """Insert a key into the B-Tree (simplified)."""
        if len(self.root.keys) == (2 * self.t - 1):
            new_root = BTreeNode()
            new_root.children.append(self.root)
            self.root = new_root
        self._insert_non_full(self.root, key)

    def _insert_non_full(self, node, key):
        """Helper function for insertion."""
        if node.leaf:
            node.keys.append(key)
            node.keys.sort()
        else:
            i = len(node.keys) - 1
            while i >= 0 and key < node.keys[i]:
                i -= 1
            self._insert_non_full(node.children[i + 1], key)


class BPlusTreeNode:
    """A B+ Tree node."""
    def __init__(self, leaf=False):
        self.leaf = leaf
        self.keys = []
        self.children = []
        self.next = None  # Pointer to next leaf node

class BPlusTree:
    """B+ Tree implementation."""
    def __init__(self, t):
        self.root = BPlusTreeNode(True)
        self.t = t

    def search(self, node, key):
        """Search a key in the B+ Tree."""
        i = 0
        while i < len(node.keys) and key > node.keys[i]:
            i += 1
        if node.leaf:
            return node if key in node.keys else None
        return self.search(node.children[i], key)

    def insert(self, key):
        """Insert a key into the B+ Tree (simplified)."""
        if len(self.root.keys) == (2 * self.t - 1):
            new_root = BPlusTreeNode()
            new_root.children.append(self.root)
            self.root = new_root
        self._insert_non_full(self.root, key)

    def _insert_non_full(self, node, key):
        """Helper function for insertion."""
        if node.leaf:
            node.keys.append(key)
            node.keys.sort()
        else:
            i = len(node.keys) - 1
            while i >= 0 and key < node.keys[i]:
                i -= 1
            self._insert_non_full(node.children[i + 1], key)


class TreeQuizApp:
    """GUI Application for B-Tree and B+ Tree Quiz"""
    def __init__(self, master):
        self.master = master
        self.master.title("B-Tree & B+ Tree Quiz")
        self.tree_type = tk.StringVar(value="B-Tree")  # Default to B-Tree
        self.btree = BTree(t=2)
        self.bplus_tree = BPlusTree(t=2)
        self.score = 0
        self.generate_question()

        # UI Components
        self.tree_type_label = tk.Label(master, text="Select Tree Type:", font=("Arial", 12))
        self.tree_type_label.pack(pady=5)

        self.tree_type_menu = tk.OptionMenu(master, self.tree_type, "B-Tree", "B+ Tree")
        self.tree_type_menu.pack(pady=5)

        self.question_label = tk.Label(master, text=self.question, font=("Arial", 14))
        self.question_label.pack(pady=10)

        self.answer_entry = tk.Entry(master, font=("Arial", 12))
        self.answer_entry.pack(pady=10)

        self.submit_button = tk.Button(master, text="Submit Answer", command=self.check_answer, font=("Arial", 12))
        self.submit_button.pack(pady=5)

        self.new_question_button = tk.Button(master, text="New Question", command=self.generate_question, font=("Arial", 12))
        self.new_question_button.pack(pady=5)

        self.score_label = tk.Label(master, text=f"Score: {self.score}", font=("Arial", 12))
        self.score_label.pack(pady=10)

        self.display_tree()

    def generate_question(self):
        """Generate a random B-Tree or B+ Tree question."""
        question_types = ["insert", "delete", "search", "traverse"]
        self.question_type = random.choice(question_types)
        self.key = random.randint(10, 100)

        if self.tree_type.get() == "B-Tree":
            if self.question_type == "insert":
                self.question = f"Insert {self.key} into the B-Tree."
                self.answer = "Inserted"

            elif self.question_type == "delete":
                self.question = f"Delete {self.key} from the B-Tree."
                self.answer = "Deleted" if self.btree.search(self.btree.root, self.key) else "Not Found"

            elif self.question_type == "search":
                self.question = f"Search for {self.key} in the B-Tree."
                self.answer = "Found" if self.btree.search(self.btree.root, self.key) else "Not Found"

            elif self.question_type == "traverse":
                self.question = "Perform an in-order traversal of the B-Tree."
                self.answer = " ".join(map(str, sorted(self.btree.root.keys)))

        elif self.tree_type.get() == "B+ Tree":
            if self.question_type == "insert":
                self.question = f"Insert {self.key} into the B+ Tree."
                self.answer = "Inserted"

            elif self.question_type == "delete":
                self.question = f"Delete {self.key} from the B+ Tree."
                self.answer = "Deleted" if self.bplus_tree.search(self.bplus_tree.root, self.key) else "Not Found"

            elif self.question_type == "search":
                self.question = f"Search for {self.key} in the B+ Tree."
                self.answer = "Found" if self.bplus_tree.search(self.bplus_tree.root, self.key) else "Not Found"

            elif self.question_type == "traverse":
                self.question = "Perform an in-order traversal of the B+ Tree."
                self.answer = " ".join(map(str, sorted(self.bplus_tree.root.keys)))

        self.question_label.config(text=self.question)

    def check_answer(self):
        """Check user’s answer."""
        user_answer = self.answer_entry.get().strip()
        if user_answer.lower() == self.answer.lower():
            self.score += 10
            messagebox.showinfo("Correct!", "Your answer is correct! ✅")
        else:
            messagebox.showerror("Incorrect!", f"Wrong answer ❌\nCorrect Answer: {self.answer}")

        self.score_label.config(text=f"Score: {self.score}")

    def display_tree(self):
        """Visualize the selected tree dynamically."""
        pass  # Placeholder for visualization

# Run the GUI application
if __name__ == "__main__":
    root = tk.Tk()
    app = TreeQuizApp(root)
    root.mainloop()
```

## Enhanced B+ Tree Quiz Application with Animations for Insert and Delete Operations

To enhance the B+ Tree Quiz Application with animations for insert and delete operations, we will:


- Use Matplotlib and NetworkX to animate tree transformations.

- Show step-by-step insertions and deletions.

- Provide visual updates on node splits and merges.

- Improve interactivity with animations.


Features in this version:

- Insert/Delete Animations

- Smooth Tree Transformations

- Real-time Updates on B+ Tree Structure

- User Interaction with Dynamic Visuals

Implementation plan:

- Track tree structure changes.

- Update visualization dynamically after each operation.

- Animate transformations (node splits, redistributions, merging).

```{python}
#| echo: TRUE
#| eval: FALSE
#| code-overflow: wrap

import tkinter as tk
from tkinter import messagebox
import random
import networkx as nx
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from PIL import Image, ImageTk
import io

class BPlusTreeNode:
    """A B+ Tree node."""
    def __init__(self, leaf=False):
        self.leaf = leaf
        self.keys = []
        self.children = []
        self.next = None  # Pointer to next leaf node

class BPlusTree:
    """B+ Tree implementation with animations."""
    def __init__(self, t):
        self.root = BPlusTreeNode(True)
        self.t = t
        self.history = []  # Store transformations for animation

    def search(self, node, key):
        """Search a key in the B+ Tree."""
        i = 0
        while i < len(node.keys) and key > node.keys[i]:
            i += 1
        if node.leaf:
            return node if key in node.keys else None
        return self.search(node.children[i], key)

    def insert(self, key):
        """Insert a key into the B+ Tree with animation tracking."""
        self.history.append(self.get_tree_snapshot())
        if len(self.root.keys) == (2 * self.t - 1):
            new_root = BPlusTreeNode()
            new_root.children.append(self.root)
            self.root = new_root
        self._insert_non_full(self.root, key)
        self.history.append(self.get_tree_snapshot())

    def _insert_non_full(self, node, key):
        """Helper function for insertion."""
        if node.leaf:
            node.keys.append(key)
            node.keys.sort()
        else:
            i = len(node.keys) - 1
            while i >= 0 and key < node.keys[i]:
                i -= 1
            self._insert_non_full(node.children[i + 1], key)

    def delete(self, key):
        """Delete a key from the B+ Tree with animation tracking."""
        self.history.append(self.get_tree_snapshot())
        self._delete_recursive(self.root, key)
        self.history.append(self.get_tree_snapshot())

    def _delete_recursive(self, node, key):
        """Recursive delete with animations."""
        if node.leaf:
            if key in node.keys:
                node.keys.remove(key)

    def get_tree_snapshot(self):
        """Returns a snapshot of the tree structure for animation."""
        snapshot = []
        self._traverse_for_snapshot(self.root, snapshot)
        return snapshot

    def _traverse_for_snapshot(self, node, snapshot):
        """Helper to traverse the tree for snapshots."""
        if node:
            snapshot.append(node.keys[:])
            for child in node.children:
                self._traverse_for_snapshot(child, snapshot)

class TreeQuizApp:
    """GUI Application for B+ Tree Quiz with Animations"""
    def __init__(self, master):
        self.master = master
        self.master.title("B+ Tree Quiz with Animations")
        self.bplus_tree = BPlusTree(t=2)
        self.score = 0
        self.animation_running = False

        self.generate_question()

        # UI Components
        self.question_label = tk.Label(master, text=self.question, font=("Arial", 14))
        self.question_label.pack(pady=10)

        self.answer_entry = tk.Entry(master, font=("Arial", 12))
        self.answer_entry.pack(pady=10)

        self.submit_button = tk.Button(master, text="Submit Answer", command=self.check_answer, font=("Arial", 12))
        self.submit_button.pack(pady=5)

        self.new_question_button = tk.Button(master, text="New Question", command=self.generate_question, font=("Arial", 12))
        self.new_question_button.pack(pady=5)

        self.score_label = tk.Label(master, text=f"Score: {self.score}", font=("Arial", 12))
        self.score_label.pack(pady=10)

        self.animate_button = tk.Button(master, text="Animate", command=self.animate_tree, font=("Arial", 12))
        self.animate_button.pack(pady=5)

        self.display_tree()

    def generate_question(self):
        """Generate a random B+ Tree question."""
        question_types = ["insert", "delete", "search"]
        self.question_type = random.choice(question_types)
        self.key = random.randint(10, 100)

        if self.question_type == "insert":
            self.question = f"Insert {self.key} into the B+ Tree."
            self.answer = "Inserted"
            self.bplus_tree.insert(self.key)

        elif self.question_type == "delete":
            self.question = f"Delete {self.key} from the B+ Tree."
            self.answer = "Deleted"
            self.bplus_tree.delete(self.key)

        elif self.question_type == "search":
            self.question = f"Search for {self.key} in the B+ Tree."
            self.answer = "Found" if self.bplus_tree.search(self.bplus_tree.root, self.key) else "Not Found"

        self.question_label.config(text=self.question)

    def check_answer(self):
        """Check user’s answer."""
        user_answer = self.answer_entry.get().strip()
        if user_answer.lower() == self.answer.lower():
            self.score += 10
            messagebox.showinfo("Correct!", "Your answer is correct! ✅")
        else:
            messagebox.showerror("Incorrect!", f"Wrong answer ❌\nCorrect Answer: {self.answer}")

        self.score_label.config(text=f"Score: {self.score}")

    def animate_tree(self):
        """Animate insert/delete operations in B+ Tree."""
        if self.animation_running:
            return
        self.animation_running = True

        fig, ax = plt.subplots(figsize=(6, 4))
        snapshots = self.bplus_tree.history

        def update(i):
            ax.clear()
            self._draw_tree(snapshots[i], ax)

        ani = animation.FuncAnimation(fig, update, frames=len(snapshots), repeat=False, interval=1000)
        plt.show()
        self.animation_running = False

    def display_tree(self):
        """Visualize the B+ Tree dynamically."""
        fig, ax = plt.subplots(figsize=(6, 4))
        self._draw_tree(self.bplus_tree.get_tree_snapshot(), ax)
        plt.show()

    def _draw_tree(self, snapshot, ax):
        """Helper function to draw B+ Tree from snapshot."""
        G = nx.DiGraph()
        self._add_edges(snapshot, G)

        pos = nx.drawing.nx_agraph.graphviz_layout(G, prog="dot")
        nx.draw(G, pos, with_labels=True, node_size=700, node_color="lightblue", edge_color="gray", font_size=10, ax=ax)

    def _add_edges(self, snapshot, G):
        """Helper to add edges for B+ Tree visualization."""
        for idx, node_keys in enumerate(snapshot):
            G.add_node(f"Node{idx}: {node_keys}")
            if idx > 0:
                G.add_edge(f"Node{idx-1}: {snapshot[idx-1]}", f"Node{idx}: {node_keys}")

# Run the GUI application
if __name__ == "__main__":
    root = tk.Tk()
    app = TreeQuizApp(root)
    root.mainloop()
```

## Complete Python implementation of a B-Tree

Below is the complete Python implementation of a B-Tree, including all fundamental operations:


- Insertion (Handles node splits)

- Deletion (Handles node merges and redistributions)

- Search (Finds if a key exists)

- Traversal (In-order traversal)

- B-Tree Visualization (Using Matplotlib & NetworkX)



```{python}
#| echo: TRUE
#| eval: FALSE
#| code-overflow: wrap

import random
import networkx as nx
import matplotlib.pyplot as plt

class BTreeNode:
    """A B-Tree node."""
    def __init__(self, t, leaf=False):
        self.t = t  # Minimum degree (defines the range for number of keys)
        self.leaf = leaf
        self.keys = []
        self.children = []

    def __repr__(self):
        return str(self.keys)


class BTree:
    """B-Tree implementation with all operations."""
    def __init__(self, t):
        self.root = BTreeNode(t, True)
        self.t = t  # Minimum degree

    def search(self, key, node=None):
        """Search a key in the B-Tree."""
        if node is None:
            node = self.root

        i = 0
        while i < len(node.keys) and key > node.keys[i]:
            i += 1

        if i < len(node.keys) and key == node.keys[i]:
            return node

        if node.leaf:
            return None

        return self.search(key, node.children[i])

    def insert(self, key):
        """Insert a key into the B-Tree."""
        root = self.root

        if len(root.keys) == (2 * self.t - 1):
            new_root = BTreeNode(self.t, False)
            new_root.children.append(self.root)
            self._split_child(new_root, 0)
            self.root = new_root

        self._insert_non_full(self.root, key)

    def _insert_non_full(self, node, key):
        """Insert a key into a non-full node."""
        i = len(node.keys) - 1

        if node.leaf:
            node.keys.append(key)
            node.keys.sort()
        else:
            while i >= 0 and key < node.keys[i]:
                i -= 1
            i += 1

            if len(node.children[i].keys) == (2 * self.t - 1):
                self._split_child(node, i)
                if key > node.keys[i]:
                    i += 1

            self._insert_non_full(node.children[i], key)

    def _split_child(self, parent, index):
        """Split a full child node."""
        t = self.t
        node = parent.children[index]
        new_node = BTreeNode(t, node.leaf)

        parent.keys.insert(index, node.keys[t - 1])
        parent.children.insert(index + 1, new_node)

        new_node.keys = node.keys[t:]
        node.keys = node.keys[:t - 1]

        if not node.leaf:
            new_node.children = node.children[t:]
            node.children = node.children[:t]

    def delete(self, key):
        """Delete a key from the B-Tree."""
        self._delete_recursive(self.root, key)

        if len(self.root.keys) == 0 and not self.root.leaf:
            self.root = self.root.children[0]

    def _delete_recursive(self, node, key):
        """Recursive delete operation."""
        t = self.t
        i = 0

        while i < len(node.keys) and key > node.keys[i]:
            i += 1

        if i < len(node.keys) and node.keys[i] == key:
            if node.leaf:
                node.keys.pop(i)
            else:
                if len(node.children[i].keys) >= t:
                    predecessor = self._get_predecessor(node.children[i])
                    node.keys[i] = predecessor
                    self._delete_recursive(node.children[i], predecessor)
                elif len(node.children[i + 1].keys) >= t:
                    successor = self._get_successor(node.children[i + 1])
                    node.keys[i] = successor
                    self._delete_recursive(node.children[i + 1], successor)
                else:
                    self._merge_nodes(node, i)
                    self._delete_recursive(node.children[i], key)
        else:
            if node.leaf:
                return

            is_last_child = (i == len(node.keys))

            if len(node.children[i].keys) < t:
                self._fill(node, i)

            if is_last_child and i > len(node.keys):
                self._delete_recursive(node.children[i - 1], key)
            else:
                self._delete_recursive(node.children[i], key)

    def _get_predecessor(self, node):
        """Find the predecessor (largest in left subtree)."""
        while not node.leaf:
            node = node.children[-1]
        return node.keys[-1]

    def _get_successor(self, node):
        """Find the successor (smallest in right subtree)."""
        while not node.leaf:
            node = node.children[0]
        return node.keys[0]

    def _merge_nodes(self, parent, index):
        """Merge a child node with its sibling."""
        child = parent.children[index]
        sibling = parent.children[index + 1]
        child.keys.append(parent.keys[index])
        child.keys.extend(sibling.keys)

        if not child.leaf:
            child.children.extend(sibling.children)

        parent.keys.pop(index)
        parent.children.pop(index + 1)

    def _fill(self, node, index):
        """Ensure that a child node has at least t keys."""
        if index > 0 and len(node.children[index - 1].keys) >= self.t:
            self._borrow_from_prev(node, index)
        elif index < len(node.children) - 1 and len(node.children[index + 1].keys) >= self.t:
            self._borrow_from_next(node, index)
        else:
            if index < len(node.children) - 1:
                self._merge_nodes(node, index)
            else:
                self._merge_nodes(node, index - 1)

    def _borrow_from_prev(self, node, index):
        """Borrow a key from the previous sibling."""
        child = node.children[index]
        sibling = node.children[index - 1]
        child.keys.insert(0, node.keys[index - 1])
        node.keys[index - 1] = sibling.keys.pop()
        if not child.leaf:
            child.children.insert(0, sibling.children.pop())

    def _borrow_from_next(self, node, index):
        """Borrow a key from the next sibling."""
        child = node.children[index]
        sibling = node.children[index + 1]
        child.keys.append(node.keys[index])
        node.keys[index] = sibling.keys.pop(0)
        if not child.leaf:
            child.children.append(sibling.children.pop(0))

    def traverse(self, node=None):
        """In-order traversal of the B-Tree."""
        if node is None:
            node = self.root
        for i in range(len(node.keys)):
            if not node.leaf:
                self.traverse(node.children[i])
            print(node.keys[i], end=" ")
        if not node.leaf:
            self.traverse(node.children[-1])

    def visualize(self):
        """Visualize the B-Tree using NetworkX and Matplotlib."""
        G = nx.DiGraph()
        self._add_edges(self.root, G)

        pos = nx.drawing.nx_agraph.graphviz_layout(G, prog="dot")
        plt.figure(figsize=(6, 4))
        nx.draw(G, pos, with_labels=True, node_size=700, node_color="lightblue", edge_color="gray", font_size=10)
        plt.show()

    def _add_edges(self, node, G, parent=None):
        """Helper function to add edges for visualization."""
        node_label = str(node.keys)
        G.add_node(node_label)
        if parent:
            G.add_edge(parent, node_label)
        for child in node.children:
            self._add_edges(child, G, node_label)

# Example Usage
btree = BTree(t=2)
keys = [20, 5, 30, 15, 25, 35, 10]
for key in keys:
    btree.insert(key)

btree.visualize()
btree.delete(15)
btree.visualize()
```

##  B-Tree visualization to include animated insertions and deletions

Key features:

- Supports All B-Tree Operations

- Handles Splits, Merges, and Borrowing

- Efficiently Deletes Keys with Rebalancing

- Visualizes the B-Tree Structure Dynamically

We will enhance the B-Tree visualization to include animated insertions and deletions. The animations will show:

- Node Splitting during Insertions

- Merging and Borrowing during Deletions

- Step-by-Step Tree Transformations

This version:


- Uses Matplotlib & NetworkX for animations.

- Tracks tree transformations during insert/delete operations.

- Displays step-by-step visual updates.


```{python}
#| echo: TRUE
#| eval: FALSE
#| code-overflow: wrap

import random
import networkx as nx
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from time import sleep

class BTreeNode:
    """A B-Tree node."""
    def __init__(self, t, leaf=False):
        self.t = t  # Minimum degree
        self.leaf = leaf
        self.keys = []
        self.children = []

    def __repr__(self):
        return str(self.keys)


class BTree:
    """B-Tree implementation with animation support."""
    def __init__(self, t):
        self.root = BTreeNode(t, True)
        self.t = t  # Minimum degree
        self.history = []  # Store transformations for animation

    def search(self, key, node=None):
        """Search a key in the B-Tree."""
        if node is None:
            node = self.root
        i = 0
        while i < len(node.keys) and key > node.keys[i]:
            i += 1
        if i < len(node.keys) and key == node.keys[i]:
            return node
        if node.leaf:
            return None
        return self.search(key, node.children[i])

    def insert(self, key):
        """Insert a key into the B-Tree with animation tracking."""
        self.history.append(self.get_tree_snapshot())  # Store initial state
        root = self.root
        if len(root.keys) == (2 * self.t - 1):
            new_root = BTreeNode(self.t, False)
            new_root.children.append(self.root)
            self._split_child(new_root, 0)
            self.root = new_root
        self._insert_non_full(self.root, key)
        self.history.append(self.get_tree_snapshot())  # Store after insert

    def _insert_non_full(self, node, key):
        """Insert into a non-full node."""
        i = len(node.keys) - 1
        if node.leaf:
            node.keys.append(key)
            node.keys.sort()
        else:
            while i >= 0 and key < node.keys[i]:
                i -= 1
            i += 1
            if len(node.children[i].keys) == (2 * self.t - 1):
                self._split_child(node, i)
                if key > node.keys[i]:
                    i += 1
            self._insert_non_full(node.children[i], key)

    def _split_child(self, parent, index):
        """Split a full child node and track changes."""
        t = self.t
        node = parent.children[index]
        new_node = BTreeNode(t, node.leaf)
        parent.keys.insert(index, node.keys[t - 1])
        parent.children.insert(index + 1, new_node)
        new_node.keys = node.keys[t:]
        node.keys = node.keys[:t - 1]
        if not node.leaf:
            new_node.children = node.children[t:]
            node.children = node.children[:t]
        self.history.append(self.get_tree_snapshot())  # Store after split

    def delete(self, key):
        """Delete a key from the B-Tree with animation tracking."""
        self.history.append(self.get_tree_snapshot())  # Store initial state
        self._delete_recursive(self.root, key)
        if len(self.root.keys) == 0 and not self.root.leaf:
            self.root = self.root.children[0]
        self.history.append(self.get_tree_snapshot())  # Store after delete

    def _delete_recursive(self, node, key):
        """Recursive delete operation."""
        t = self.t
        i = 0
        while i < len(node.keys) and key > node.keys[i]:
            i += 1
        if i < len(node.keys) and node.keys[i] == key:
            if node.leaf:
                node.keys.pop(i)
            else:
                if len(node.children[i].keys) >= t:
                    predecessor = self._get_predecessor(node.children[i])
                    node.keys[i] = predecessor
                    self._delete_recursive(node.children[i], predecessor)
                elif len(node.children[i + 1].keys) >= t:
                    successor = self._get_successor(node.children[i + 1])
                    node.keys[i] = successor
                    self._delete_recursive(node.children[i + 1], successor)
                else:
                    self._merge_nodes(node, i)
                    self._delete_recursive(node.children[i], key)
        else:
            if node.leaf:
                return
            is_last_child = (i == len(node.keys))
            if len(node.children[i].keys) < t:
                self._fill(node, i)
            if is_last_child and i > len(node.keys):
                self._delete_recursive(node.children[i - 1], key)
            else:
                self._delete_recursive(node.children[i], key)
        self.history.append(self.get_tree_snapshot())  # Store after delete

    def get_tree_snapshot(self):
        """Capture a snapshot of the tree structure."""
        snapshot = []
        self._traverse_for_snapshot(self.root, snapshot)
        return snapshot

    def _traverse_for_snapshot(self, node, snapshot):
        """Helper to traverse the tree for snapshots."""
        if node:
            snapshot.append(node.keys[:])
            for child in node.children:
                self._traverse_for_snapshot(child, snapshot)

    def visualize(self):
        """Visualize the B-Tree using Matplotlib."""
        G = nx.DiGraph()
        self._add_edges(self.root, G)

        pos = nx.drawing.nx_agraph.graphviz_layout(G, prog="dot")
        plt.figure(figsize=(6, 4))
        nx.draw(G, pos, with_labels=True, node_size=700, node_color="lightblue", edge_color="gray", font_size=10)
        plt.show()

    def animate_tree(self):
        """Animate insert/delete operations in B-Tree."""
        fig, ax = plt.subplots(figsize=(6, 4))
        snapshots = self.history

        def update(i):
            ax.clear()
            self._draw_tree(snapshots[i], ax)

        ani = animation.FuncAnimation(fig, update, frames=len(snapshots), repeat=False, interval=1000)
        plt.show()

    def _draw_tree(self, snapshot, ax):
        """Helper function to draw B-Tree from snapshot."""
        G = nx.DiGraph()
        self._add_edges_snapshot(snapshot, G)

        pos = nx.drawing.nx_agraph.graphviz_layout(G, prog="dot")
        nx.draw(G, pos, with_labels=True, node_size=700, node_color="lightblue", edge_color="gray", font_size=10, ax=ax)

    def _add_edges_snapshot(self, snapshot, G):
        """Helper to add edges for visualization."""
        for idx, node_keys in enumerate(snapshot):
            G.add_node(f"Node{idx}: {node_keys}")
            if idx > 0:
                G.add_edge(f"Node{idx-1}: {snapshot[idx-1]}", f"Node{idx}: {node_keys}")

# Example Usage
btree = BTree(t=2)
keys = [20, 5, 30, 15, 25, 35, 10]
for key in keys:
    btree.insert(key)

btree.visualize()
btree.animate_tree()

btree.delete(15)
btree.visualize()
btree.animate_tree()
```

## Complete Python Implementation of a B+ Tree

Below is the complete Python implementation of a B+ Tree, including all fundamental operations:

- Insertion (Handles node splits)

- Deletion (Handles node merges and redistributions)

- Search (Finds if a key exists)

- Traversal (In-order traversal & range queries)

- Visualization Support (For animations later)


```{python}
#| echo: TRUE
#| eval: FALSE
#| code-overflow: wrap

import networkx as nx
import matplotlib.pyplot as plt

class BPlusTreeNode:
    """A B+ Tree node."""
    def __init__(self, leaf=False):
        self.leaf = leaf
        self.keys = []
        self.children = []
        self.next = None  # Pointer to next leaf node (for range queries)

    def __repr__(self):
        return str(self.keys)


class BPlusTree:
    """B+ Tree implementation with all operations."""
    def __init__(self, t):
        self.root = BPlusTreeNode(True)
        self.t = t  # Minimum degree

    def search(self, key, node=None):
        """Search for a key in the B+ Tree."""
        if node is None:
            node = self.root

        i = 0
        while i < len(node.keys) and key > node.keys[i]:
            i += 1

        if node.leaf:
            return node if key in node.keys else None

        return self.search(key, node.children[i])

    def insert(self, key):
        """Insert a key into the B+ Tree."""
        root = self.root

        if len(root.keys) == (2 * self.t - 1):  # Node full
            new_root = BPlusTreeNode(False)
            new_root.children.append(self.root)
            self._split_child(new_root, 0)
            self.root = new_root

        self._insert_non_full(self.root, key)

    def _insert_non_full(self, node, key):
        """Insert into a non-full node."""
        i = len(node.keys) - 1

        if node.leaf:
            node.keys.append(key)
            node.keys.sort()
        else:
            while i >= 0 and key < node.keys[i]:
                i -= 1
            i += 1

            if len(node.children[i].keys) == (2 * self.t - 1):
                self._split_child(node, i)
                if key > node.keys[i]:
                    i += 1

            self._insert_non_full(node.children[i], key)

    def _split_child(self, parent, index):
        """Split a full child node."""
        t = self.t
        node = parent.children[index]
        new_node = BPlusTreeNode(node.leaf)

        parent.keys.insert(index, node.keys[t - 1])
        parent.children.insert(index + 1, new_node)

        new_node.keys = node.keys[t:]
        node.keys = node.keys[:t - 1]

        if not node.leaf:
            new_node.children = node.children[t:]
            node.children = node.children[:t]
        else:
            new_node.next = node.next  # Maintain linked list for range queries
            node.next = new_node

    def delete(self, key):
        """Delete a key from the B+ Tree."""
        self._delete_recursive(self.root, key)

        if len(self.root.keys) == 0 and not self.root.leaf:
            self.root = self.root.children[0]

    def _delete_recursive(self, node, key):
        """Recursive delete operation."""
        t = self.t
        i = 0

        while i < len(node.keys) and key > node.keys[i]:
            i += 1

        if i < len(node.keys) and node.keys[i] == key:
            if node.leaf:
                node.keys.pop(i)
            else:
                if len(node.children[i].keys) >= t:
                    predecessor = self._get_predecessor(node.children[i])
                    node.keys[i] = predecessor
                    self._delete_recursive(node.children[i], predecessor)
                elif len(node.children[i + 1].keys) >= t:
                    successor = self._get_successor(node.children[i + 1])
                    node.keys[i] = successor
                    self._delete_recursive(node.children[i + 1], successor)
                else:
                    self._merge_nodes(node, i)
                    self._delete_recursive(node.children[i], key)
        else:
            if node.leaf:
                return

            is_last_child = (i == len(node.keys))

            if len(node.children[i].keys) < t:
                self._fill(node, i)

            if is_last_child and i > len(node.keys):
                self._delete_recursive(node.children[i - 1], key)
            else:
                self._delete_recursive(node.children[i], key)

    def _get_predecessor(self, node):
        """Find the predecessor (largest in left subtree)."""
        while not node.leaf:
            node = node.children[-1]
        return node.keys[-1]

    def _get_successor(self, node):
        """Find the successor (smallest in right subtree)."""
        while not node.leaf:
            node = node.children[0]
        return node.keys[0]

    def _merge_nodes(self, parent, index):
        """Merge a child node with its sibling."""
        child = parent.children[index]
        sibling = parent.children[index + 1]
        child.keys.append(parent.keys[index])
        child.keys.extend(sibling.keys)

        if not child.leaf:
            child.children.extend(sibling.children)

        parent.keys.pop(index)
        parent.children.pop(index + 1)

    def _fill(self, node, index):
        """Ensure that a child node has at least t keys."""
        if index > 0 and len(node.children[index - 1].keys) >= self.t:
            self._borrow_from_prev(node, index)
        elif index < len(node.children) - 1 and len(node.children[index + 1].keys) >= self.t:
            self._borrow_from_next(node, index)
        else:
            if index < len(node.children) - 1:
                self._merge_nodes(node, index)
            else:
                self._merge_nodes(node, index - 1)

    def _borrow_from_prev(self, node, index):
        """Borrow a key from the previous sibling."""
        child = node.children[index]
        sibling = node.children[index - 1]
        child.keys.insert(0, node.keys[index - 1])
        node.keys[index - 1] = sibling.keys.pop()
        if not child.leaf:
            child.children.insert(0, sibling.children.pop())

    def _borrow_from_next(self, node, index):
        """Borrow a key from the next sibling."""
        child = node.children[index]
        sibling = node.children[index + 1]
        child.keys.append(node.keys[index])
        node.keys[index] = sibling.keys.pop(0)
        if not child.leaf:
            child.children.append(sibling.children.pop(0))

    def range_query(self, start, end):
        """Perform a range query on the B+ Tree."""
        node = self.root
        while not node.leaf:
            i = 0
            while i < len(node.keys) and start > node.keys[i]:
                i += 1
            node = node.children[i]

        results = []
        while node:
            for key in node.keys:
                if start <= key <= end:
                    results.append(key)
            node = node.next

        return results

    def visualize(self):
        """Visualize the B+ Tree using NetworkX."""
        G = nx.DiGraph()
        self._add_edges(self.root, G)

        pos = nx.drawing.nx_agraph.graphviz_layout(G, prog="dot")
        plt.figure(figsize=(6, 4))
        nx.draw(G, pos, with_labels=True, node_size=700, node_color="lightblue", edge_color="gray", font_size=10)
        plt.show()

    def _add_edges(self, node, G, parent=None):
        """Helper function to add edges for visualization."""
        node_label = str(node.keys)
        G.add_node(node_label)
        if parent:
            G.add_edge(parent, node_label)
        for child in node.children:
            self._add_edges(child, G, node_label)

# Example Usage
bplus_tree = BPlusTree(t=2)
keys = [20, 5, 30, 15, 25, 35, 10]
for key in keys:
    bplus_tree.insert(key)

bplus_tree.visualize()
bplus_tree.delete(15)
bplus_tree.visualize()
```

## B+ Tree Visualization for Insertions and Deletions

We will now enhance the B+ Tree visualization to include animated insertions and deletions. The animations will show:

- Node Splitting during Insertions

- Merging and Borrowing during Deletions

- Step-by-Step Tree Transformations

This version:

- Uses Matplotlib & NetworkX for animations.

- Tracks tree transformations during insert/delete operations.

- Displays step-by-step visual updates.


```{python}
#| echo: TRUE
#| eval: FALSE
#| code-overflow: wrap

import networkx as nx
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from time import sleep

class BPlusTreeNode:
    """A B+ Tree node."""
    def __init__(self, leaf=False):
        self.leaf = leaf
        self.keys = []
        self.children = []
        self.next = None  # Pointer to next leaf node (for range queries)

    def __repr__(self):
        return str(self.keys)


class BPlusTree:
    """B+ Tree implementation with animations."""
    def __init__(self, t):
        self.root = BPlusTreeNode(True)
        self.t = t
        self.history = []  # Store transformations for animation

    def search(self, key, node=None):
        """Search for a key in the B+ Tree."""
        if node is None:
            node = self.root

        i = 0
        while i < len(node.keys) and key > node.keys[i]:
            i += 1

        if node.leaf:
            return node if key in node.keys else None

        return self.search(key, node.children[i])

    def insert(self, key):
        """Insert a key into the B+ Tree with animation tracking."""
        self.history.append(self.get_tree_snapshot())  # Store initial state
        root = self.root

        if len(root.keys) == (2 * self.t - 1):  # Node full
            new_root = BPlusTreeNode(False)
            new_root.children.append(self.root)
            self._split_child(new_root, 0)
            self.root = new_root

        self._insert_non_full(self.root, key)
        self.history.append(self.get_tree_snapshot())  # Store after insert

    def _insert_non_full(self, node, key):
        """Insert into a non-full node."""
        i = len(node.keys) - 1

        if node.leaf:
            node.keys.append(key)
            node.keys.sort()
        else:
            while i >= 0 and key < node.keys[i]:
                i -= 1
            i += 1

            if len(node.children[i].keys) == (2 * self.t - 1):
                self._split_child(node, i)
                if key > node.keys[i]:
                    i += 1

            self._insert_non_full(node.children[i], key)

    def _split_child(self, parent, index):
        """Split a full child node and track changes."""
        t = self.t
        node = parent.children[index]
        new_node = BPlusTreeNode(node.leaf)

        parent.keys.insert(index, node.keys[t - 1])
        parent.children.insert(index + 1, new_node)

        new_node.keys = node.keys[t:]
        node.keys = node.keys[:t - 1]

        if not node.leaf:
            new_node.children = node.children[t:]
            node.children = node.children[:t]
        else:
            new_node.next = node.next  # Maintain linked list for range queries
            node.next = new_node

        self.history.append(self.get_tree_snapshot())  # Store after split

    def delete(self, key):
        """Delete a key from the B+ Tree with animation tracking."""
        self.history.append(self.get_tree_snapshot())  # Store initial state
        self._delete_recursive(self.root, key)
        if len(self.root.keys) == 0 and not self.root.leaf:
            self.root = self.root.children[0]
        self.history.append(self.get_tree_snapshot())  # Store after delete

    def _delete_recursive(self, node, key):
        """Recursive delete operation."""
        t = self.t
        i = 0
        while i < len(node.keys) and key > node.keys[i]:
            i += 1

        if i < len(node.keys) and node.keys[i] == key:
            if node.leaf:
                node.keys.pop(i)
            else:
                self._merge_nodes(node, i)
                self._delete_recursive(node.children[i], key)
        else:
            if node.leaf:
                return
            self._delete_recursive(node.children[i], key)

        self.history.append(self.get_tree_snapshot())  # Store after delete

    def _merge_nodes(self, parent, index):
        """Merge a child node with its sibling."""
        child = parent.children[index]
        sibling = parent.children[index + 1]
        child.keys.append(parent.keys[index])
        child.keys.extend(sibling.keys)

        if not child.leaf:
            child.children.extend(sibling.children)

        parent.keys.pop(index)
        parent.children.pop(index + 1)

    def get_tree_snapshot(self):
        """Capture a snapshot of the tree structure."""
        snapshot = []
        self._traverse_for_snapshot(self.root, snapshot)
        return snapshot

    def _traverse_for_snapshot(self, node, snapshot):
        """Helper to traverse the tree for snapshots."""
        if node:
            snapshot.append(node.keys[:])
            for child in node.children:
                self._traverse_for_snapshot(child, snapshot)

    def animate_tree(self):
        """Animate insert/delete operations in B+ Tree."""
        fig, ax = plt.subplots(figsize=(6, 4))
        snapshots = self.history

        def update(i):
            ax.clear()
            self._draw_tree(snapshots[i], ax)

        ani = animation.FuncAnimation(fig, update, frames=len(snapshots), repeat=False, interval=1000)
        plt.show()

    def _draw_tree(self, snapshot, ax):
        """Helper function to draw B+ Tree from snapshot."""
        G = nx.DiGraph()
        self._add_edges_snapshot(snapshot, G)

        pos = nx.drawing.nx_agraph.graphviz_layout(G, prog="dot")
        nx.draw(G, pos, with_labels=True, node_size=700, node_color="lightblue", edge_color="gray", font_size=10, ax=ax)

    def _add_edges_snapshot(self, snapshot, G):
        """Helper to add edges for visualization."""
        for idx, node_keys in enumerate(snapshot):
            G.add_node(f"Node{idx}: {node_keys}")
            if idx > 0:
                G.add_edge(f"Node{idx-1}: {snapshot[idx-1]}", f"Node{idx}: {node_keys}")

# Example Usage
bplus_tree = BPlusTree(t=2)
keys = [20, 5, 30, 15, 25, 35, 10]
for key in keys:
    bplus_tree.insert(key)

bplus_tree.animate_tree()

bplus_tree.delete(15)
bplus_tree.animate_tree()
```

